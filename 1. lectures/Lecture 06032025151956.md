---
tags:
  - category/lecture
  - status/pending
  - topic/sistemi-operativi
date: 06-03-2025 15:19:56
teacher: renzo.davoli@unibo.it
mod: 2
---
# Lezione
---
## Concetti
- **scheduling**
	- il sistema operativo è un gestore di risorse
	- ha bisogno di strutture dati per gestirle
		- tabelle di memoria
		- tabelle di I/O
		- tabelle del file system
		- tabelle dei processi (PCB)
	- quella più importante è la tabella dei processi
		- un processo si identifica da
			- codice da eseguire
			- dati su cui operare
			- stack di lavoro per la gestione di chiamate di funzione, passaggio di parametri e variabili locali
			- insieme di attributi contenenti tutte le informazioni necessarie per la gestione del processo stesso
				- questo insieme si chiama PCB, Process Control Block
		- la tabella dei processi contiene i PCB, uno per ogni processo
			- contenuto PCB
				- _identificazione di processo_
					- `pid` (process identifier)
						- si potrebbe usare l'indice dell'array della tabella, ma causa il problema della reincarnazione
						- si potrebbe anche usare un numero progressivo --> quello che viene usato
					- identificatori di altri processi correlati (come il `pid` del processo padre)
					- identificatore dell'utente che ha richiesto l'esecuzione del processo
				- _stato del processo_
					- registri generali del processore
					- registri speciali del processore (PC e PSW)
					- informazioni di scheduling varie
				- _controllo del processo_
					- gestione della memoria
					- accounting (importanti per misurare le prestazioni!)
					- relative alle risorse
					- interprocess comunication (IPC)
	- **scheduler**
		- è il componente più importante del kernel
		- gestisce l'avvicendamento dei processi, assegnando la CPU di volta in volta a un processo
		- quando viene richiamato decide quale processo viene mandato in esecuzione
		- quando interviene?
			- quando viene richiesta un'operazione di I/O
			- quando un'operazione di I/O termina (l'[[Interval timer]] si comporta come un device di I/O)
		- li scheduler sono tanti, nel senso che ogni dispositivo in realtà può avere un suo scheduler
		- mode switching e contex switching
			- _mode switching_ --> quando c'è un interrupt (hardware o software), il processore ne è soggetto, ossia passa da modalità utente a modalità kernel
			- _context switching_ --> quando lo scheduler decide di eseguire un altro processo, allora il processore ne è soggetto, ossia deve cambiare il suo stato sulla base di quello del nuovo PCB
				- operazioni da fare
					- lo stato del processo attuale viene salvato nel PCB corrispondente
					- lo stato del processo selezionato per l'esecuzione viene caricato nel PCB del processore (`LDST`)
		- vita di un processo
			- stati
				- _running_: in esecuzione
					- può andare direttamente in ready senza bloccarsi, magari per system call non bloccanti come `getpid()`
				- _waiting_: aspetta un qualche evento esterno, come il completamento di un I/O
				- _ready_: è pronto per partire ma attualmente il processore ha già un processo in esecuzione
					- nel nostro caso, tutti gli 8 processori sono occupati
			- code dei processi, per implementare gli stati
				- _ready queue_: struttura dati da cui lo scheduler sceglie il processo da eseguire
				- le altre code, quelle per l'attesa per esempio, sono implementati dai semafori! per ogni device infatti ci sarà un semaforo con associata una coda di attesa
		- gerarchia di processi
			- quando un processo crea un nuovo processo, il creante viene detto padre, mentre il creato figlio
			- è comodo fare le cose così, perché quando creiamo un processo questo eredita un sacco di campi dal genitore, tranne quelli che vogliamo specificare
			- il processo adamo/eva è `/sbin/init`, che infatti ha `pid` a 1
				- tra l'altro eredita tutti gli orfani
		- processi vs. thread
			- un processo è singolo, che esegue una singola sequenza di istruzioni
			- i thread sono fondamentalmente delle attività del processo, che possono essere eseguite contemporaneamente
			- tutti i sistemi operativi moderni supportano processi multithreaded
			- avviene che
				- in realtà i thread sono realmente le cose eseguite dalla CPU
				- i processi non diventano altro che i titolari dei thread!
				- per cui ogni thread ha delle informazioni sue (tra cui stack separati)
				- nei sistemi multithreaded, allora lo scheduler allora fa scheduling sui thread, non sui processi!
			- motivazione
				- è più efficiente sincronizzare i thread che i processi
				- tra processi dovremmo adottare message passing! invece con i thread possiamo usare i semafori
					- questo perché in uno stesso processo la memoria è condivisa tra i thread; mentre tra processi diversi la memoria è privata
	- **scheduling**
		- usiamo un diagramma di gantt per rappresentare uno schedule
		- eventi che possono causare un context switch
			1. quando un processo passa da stato running a waiting
			2. quando un processo passa dallo stato running allo stato ready
			3. quando un processo passa dallo stato waiting allo stato ready
			4. quando un processo termina
		- tipi
			- non-preemptive o cooperativo
				- solo se i context switch avvengono nelle condizioni 1 e 4
				- in altre parole: il controllo della risorsa viene trasferito solo se l'assegnatario attuale lo cede volontariamente
				- non ha bisogno di meccanismi hardware, come ad esempio timer programmabili
			- preemptive
				- se i context switch possono avvenire in ogni condizione
				- in altre parole: è possibile che il controllo della risorsa venga tolto all'assegnatario attuale a causa di un evento
				- tutti gli scheduler moderni
				- permette di usare al meglio le risorse
		- criteri di scelta dello scheduler
			- _utilizzo della risorsa CPU_ --> dev'essere massimizzato
			- _throughput_ --> numero di processi completati per unità di tempo (dipende dalla lunghezza dei processi), dev'essere massimizzato
			- _tempo di turnaround_ --> tempo che intercorre dalla sottomissione di un processo alla sua terminazione, dev'essere minimizzato
			- _tempo di attesa_ --> tempo trascorso da un processo nella ready queue, dev'essere minimizzato
			- _tempo di prima risposta_ --> tempo che intercorre tra la sottomissione di un processo e il tempo di prima risposta, significativo nei programmi interattivi!
		- caratteristiche dei processi
			- si alternano
				- **CPU burst**, periodi di attività della CPU
				- **I/O burst**, periodi di attività di I/O
			- quindi i processi possono essere
				- **CPU bound**, caratterizzati da tempi di CPU burst molto lunghi
				- **I/O bound**, caratterizzati da tempi di I/O burst molto lunghi
		- algoritmi
			- **First Come, First Served** (**FCFS**)
				- non è preemptive
				- semplice, implementato tramite una coda (FIFO)
				- elevati tempi medi di attesa e di turnaround
				- processi CPU bound ritardano processi I/O bound
				- _Convoy effect_
			- **Shortest Job First** (**SJF**)
				- la CPU viene assegnata al processo ready che ha la minima durata del CPU burst successivo
				- politica senza preemption
				- è ottimale rispetto al tempo medio di attesa (dimostrato, approccio greedy); ma è impossibile da implementare in pratica
				- inoltre può essere soggetto a starvation
				- infatti si può solo stimare il CPU burst del prossimo processo, magari sulla base di quelli precedenti
					- di solito si fa con la _media esponenziale_ dei CPU burst precedenti
					- si risolve la formula rappresentandola come [[Equazione di ricorrenza|equazione di ricorrenza]]
				- esiste anche la sua versione preemptive
					- se arriva un processo con un CPU burst più breve di quanto rimane da eseguire al processo corrente, quest'ultimo viene messo nella ready queue
			- **Round-Robin**
				- ogni processo non può rimanere in esecuzione per un tempo superiore alla durata del quanto di tempo (interval timer)
				- i processi sono nella ready queue
					- un processo può lasciare il processore volontariamente, in seguito ad un'operazione di I/O
					- un processo può esaurire il suo quanto di tempo senza completare il suo CPU burst, nel qual caso viene messo in fondo alla ready queue
				- il quanto di tempo è un parametro critico del sistema
					- se è troppo basso faccio troppi context switch di seguito, e questo occupa del tempo
					- se è troppo alto si paga in responsività dei programmi
				- è necessario avere un dispositivo hardware che fornisca un timer (interval timer) che agisca come "sveglia" del processore

## Domande

## Referenze
