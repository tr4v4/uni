---
tags:
  - category/lecture
  - status/finished
  - topic/ingegneria-del-software
date: 22-09-2025 10:09:02
teacher: giancarlo.succi2@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- lunedì - teoria
- mercoledì - esercitazioni
- esame
	- orale - su tutto il corso
	- scritto (prima sessione solo) - al posto dell'orale
	- progetto - per chi vuole, riducono domande scritto a 3 (da 10), è più arduo
	- andare in Cina per internship
	- comunque può facilitare tirocinio in Germania
- contenuto
	- noi studieremo linguaggi orientati agli oggetti
	- oggetto - 2 significati
		1. la classe è una struttura dati, che contiene
			- campi
			- metodi
		2. la computazione procede tramite l'interazione tra gli oggetti
			- infatti "metodo" deriva da "metodo di risposta", e il punto "." è chiamato operatore "send" del messaggio
	- il primo linguaggio orientato a oggetti è Simula66 (del 1966)
	- all'inizio le 2 parti erano un tutt'uno: negli anni 70 la parte di computazione tramite interazione si è separata, diventando programmazione ad attori, o ad agenti
	- i 3 paradigmi principali sono
		- imperativo
		- funzionale
		- ad oggetti
	- è chiaro che tutto si riduce all'approccio imperativo (per esempio i metodi implementano pezzetti di codice imperativo), ma cambia l'idea dei paradigmi
	- caratteristiche comuni linguaggi orientati ad oggetti
		- classe - ma attenzione, Ada per esempio ha classi ma non è ad oggetti
		- ereditarietà - ma anche qui attenzione, Rust (se lo consideriamo ad oggetti) e Go non hanno l'ereditarietà
		- polimorfismo - stesso nome associato a comportamenti diversi, 3 tipi
			- ad hoc - overloading
			- parametrico - generico
				- nota bene: anche in C con le macro si può fare polimorfismo generico, e con i puntatori a void
				- in C++ si fanno con i template, che generano tutti i codici per ogni tipo possibile, di fatto espandendo tantissimo il codice
					- con la template specialization si possono creare gerarchie di template
				- in Java con la type erasure
			- virtual function - overriding
				- è importantissimo, perché associato al late binding
					- l'associazione tra nome e corpo della funzione non è fatta a compilazione ma a tempo di esecuzione
					- anche in C si può fare con i puntatori a funzione
				- introduzione
					- si vuole cercare di determinare il comportamento degli oggetti il più tardi possibile, se possibile addirittura a run-time
						- è come si definiscono le specifiche di un cliente, passo dopo passo, non immediatamente sin da subito
						- "la comprensione è incrementale"
					- le funzioni virtuali sono un modello elegante e flessibile per gestire il cambiamento delle specifiche del cliente
					- si implementano con il late binding (linguaggi)
				- definizione - è un metodo di una classe che può essere ridefinito in una classe derivata
					- questa ridefinizione è chiamata overriding
						- ossia la sovrascrizione a run-time di un metodo con un altro metodo, e può succedere
							- se il metodo sovrascritto è virtuale (di solito tutti i metodi sono virtuali se non specificato)
							- se il metodo nuovo ha la stessa firma e lo stesso tipo di ritorno del metodo sovrascritto
								- nota bene: la firma non include il tipo di ritorno
								- firma e tipo di ritorno formano il prototipo
						- nota bene: si sa solo a run-time quale metodo verrà eseguito!
						- i metodi statici non possono essere sovrascritti
				- comportamento
					- se il metodo virtuale è invocato su un oggetto di cui si sa il tipo a compile-time, allora si comporta come la sua equivalente versione non-virtuale
					- abbiamo funzione `f` invocata su oggetto `o` di classe `D` derivata da `B`, i comportamenti sono:
						- `f` definita solo in `D` -> chiamo `D.f`
						- `f` definita solo in `B` -> chiamo `B.f`
						- `f` definita entrambi -> se `B` overrida e `f` è virtuale allora chiamo `B.f`
					- caso complesso se `B* pd = new D()`
				- sono utilissime
				- in Java e in C++
					- Java
						- tutti i metodi non-statici sono virtuali, non serve mettere virtual
							- se non si vuole che sia virtuale, si mette `final`
							- addirittura ci sono le classi `final`
					- C++
						- un metodo dev'essere dichiarato virtuale in modo specifico
						- non c'è keyword `final`
						- se non si mette `virtual` il late-binding semplicemente non viene realizzato
					- esempio di array di veicoli
						- nota i puntatori in C++ --> servono per poter fare il late binding! Infatti anche in Java in realtà sono puntatori --> se fossero oggetti diretti non funzionerebbe
							- in C++ viene fatta la copia bitwise!
							- anzi:
								- prima cerca se c'è l'operatore di assegnamento tra Animal e Dog
								- se non lo trova cerca la copia di struttura definita dall'utente
								- se non trova neanche quella, fa la copia bitwise, copiando `Dog` in `Animal`, comportamento impredicibile! (perché Dog è più grande)
									- se si copiasse Animal in Dog sarebbe giusto, perché Animal è più piccolo
				- binding
					- early binding - comportamento standard di C++
					- late binding - il compilatore non può dedurre dove trovare la funzione, serve farlo a run-time --> si usa la v-table
						- ogni classe con funzione virtuale ha VFT, che contiene i puntatori ai codici implementativi di ogni virtual function
				- perché non si usa sempre virtual? Perché è costoso il late binding...
				- esercizio
					- B::f()
					- A::g()
					- B::f()
					- A::g()
					- A::i()
 
## Domande

## Referenze
