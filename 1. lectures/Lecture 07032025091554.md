---
tags:
  - category/lecture
  - status/ongoing
  - topic/sistemi-operativi
date: 07-03-2025 09:15:54
teacher: renzo.davoli@unibo.it
mod: 2
---
# Lezione
---
## Concetti
- **scheduling** - continuo
	- **Round-Robin**
		- implementazione
			- è necessario un device hardware, l'interval timer
		- è democratico
			- ma i processi non sono tutti uguali --> la visualizzazione di un video potrebbe essere ritardata da un processo che smista la posta elettronica
			- quindi c'è bisogno di assegnare priorità ai processi, e di trasformare la ready queue in una _coda con priorità_
	- **scheduling a priorità**
		- con priorità
			- _definite dal sistema_
				- sono usate quantità misurabili per calcolare la priorità di un processo
				- come nel caso del SJF: è un sistema basato su priorità, dove la priorità è il CPU burst
			- _definite esternamente_
				- le priorità sono imposte dal livello utente (con system call `NICE`)
				- UNIX, di base, dà priorità massima ai processi utente
		- la priorità può essere
			- _statica_ --> potrebbe causare starvation per i processi a bassa priorità
			- _dinamica_ --> si possono sfruttare metodologie di priorità dinamica per evitare starvation (come far crescere la priorità di un processo man mano che rimane nella ready queue)
				- questa tecnica si chiama _aging_: consiste nell'incrementare gradualmente la priorità dei processi in attesa
				- se si assume che la variazione delle priorità sia limitata, nessun processo rimarrà in attesa per un tempo indefinito perché prima o poi raggiungerà la priorità massima --> no starvation!
	- **scheduling a classi di priorità**
		- al posto di avere una priorità per ogni processo, si hanno delle classi di priorità, e ogni processo viene assegnato a una certa classe
		- la coda ready quindi è suddivisa in sottocode, e viene scelta la sottocoda della classe a priorità massima (non vuota)
	- **scheduling multilivello**
		- ha delle classi di priorità, ma ogni classe ha un algoritmo di scheduling diverso!
		- per esempio, possiamo fare 4 classi di processi (priorità decrescente)
			- _processi server_ (priorità statica)
			- _processi utente interattivi_ (round-robin)
			- _altri processi utente_ (FIFO)
			- _processo vuoto_ (FIFO banale)
		- nei sistemi multilivello, ogni sottocoda (classe), se vuota, crea un processo vuoto che serve a mettere in `WAIT` lo scheduler
	- **scheduling real-time**
		- i processi sono
			- _periodici_, sono processi che vengono riattivati con cadenza regolare
			- _aperiodici_, sono processi scatenati da un evento sporadico
		- scheduler
			- _rate monotonic_ (preferito)
			- _earliest deadline first_
- esercizi
- **gestione risorse e deadlock**
	- **gestione risorse**
		- un sistema possiamo vederlo come un complesso di risorse da assegnare ai processi presenti
		- esempi:
			- HW --> memoria, stampanti, processore, dischi, interfaccia di rete
			- SW --> sezioni critiche, descrittori di processo
		- possono essere divide in classi
			- le risorse appartenenti alla stessa classe sono equivalenti
			- ogni risorsa viene detta istanza della classe a cui appartiene
			- il numero di risorse in una classe viene detto molteplicità del tipo di risorsa
		- _un processo non richiede una specifica risorsa --> richiede una risorsa di una specifica classe_!
		- assegnazione
			- statica --> avviene al momento della creazione del processo e rimane valida fino alla terminazione
			- dinamica --> le risorse possono essere assegnate e rilasciate quando non più necessarie (come la terminazione di un processo, si libera il PCB)
		- tipi di richieste, singola (se ne richiede una sola) o multipla (si riferisce ad una o più classi e di queste a una o più risorse)
		- tipi di richieste, bloccanti (il processo si sospende se non ottiene immediatamente l'assegnazione), non bloccante (la mancata assegnazione non provoca la sospensione del processo richiedente)
		- tipi di risorse, non condivisibili (non può essere assegnata a più processi contemporaneamente) o condivisibili (contrario)
		- tipi di risorse
			- prerilasciabili (o preemptable) --> la funzione di gestione della risorsa può rilasciarla a un processo prima che questo l'abbia rilasciata volontariamente
				- come lo scheduling preemptive
				- si gestisce sospendendo il processo che subisce il prerilascio, la risorsa prerilasciata sarà restituita al processo
				- condizioni
					- il suo stato non si modifica durante l'utilizzo
					- il suo stato può essere facilmente salvato e ripristinato
				- esempio: processore, e blocchi/partizioni di memoria sono prerilasciabili
			- non prerilasciabili
				- non si possono sottrarre al processo a cui sono state assegnate prima che questo non la rilasci volontariamente
				- esempio: una stampante non può essere prerilasciabile, così come la sezione critica
	- **deadlock**
		- condizioni
			- la risorsa dev'essere non condivisibile (mutua esclusione)
			- assenza di prerilascio, le risorse non devono essere prerilasciabili
			- richieste bloccanti (detta anche "hold and wait")
			- attesa circolare
		- l'insieme di queste condizioni è necessario e sufficiente affinché si presenti deadlock nel sistema
		- **grafo di Holt**
			- è un grafo orientato e bipartito, tale per cui nodi dello stesso sottoinsieme non sono collegati da alcun arco
			- gli archi _risorsa -> processo_ indica che la risorsa è assegnata al processo
			- gli archi _processo -> risorsa_ indica che il processo ha richiesto la risorsa
		- possiamo fare
			- _detection_, strumento per capire se c'è deadlock
				- usiamo i grafi di holt
				- caso 1 risorsa per classe
					- teorema: se le risorse sono a richiesta bloccante, non condivisibili e non prerilasciabili, lo stato è di deadlock sse il grafo di Holt contiene un ciclo
				- caso più risorse per classe
					- riducibilità: un grafo di Holt è riducibile se esiste almeno un nodo processo con solo archi entranti
					- quindi ridurre il grafo per un certo nodo significa eliminare tutti gli archi di tale nodo e riassegnare le risorse ad altri processi --> possiamo farlo perché un nodo processo con solo archi entranti prima o poi terminerà perché ha tutte le risorse di cui ha bisogno
					- teorema: lo stato non è di deadlock sse il grafo di Holt è completamente riducibile (o contronominale)
				- altro modo - knot
					- dato un nodo $n$ l'insieme dei nodi raggiungibili da $n$ viene detto _insieme di raggiungibilità_ di $n$ ($R(n)$)
					- un knot del grafo $G$ è il sottoinsieme (non banale) di nodi $M$ tale che per ogni $n$ in $M$ vale $R(n) = M$
					- teorema: dato un grafo di Holt con una sola richiesta sospesa per processo, il grafo rappresenta uno stato di deadlock sse esiste un knot
			- _prevention_, 
			- _avoidance_, 

## Domande

## Referenze
