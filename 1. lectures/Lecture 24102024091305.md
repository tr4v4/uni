---
tags:
  - category/lecture
  - status/pending
  - topic/sistemi-operativi
date: 24-10-2024 09:13:05
teacher: renzo.davoli@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- ripasso algoritmo di Dekker
- **algoritmo di Peterson**
	- più semplice e lineare, ma equivalente
	- scalabile a $N$ processi
	- dimostrazione
		- mutua esclusione
			- supponiamo $P$ in sezione critica
			- vogliamo provare che $Q$ non può entrare
			- sappiamo `needp = true`
			- $Q$ entra se `turn = Q` quando esegue il `while`
			- deve passare quel `while`, allora sapendo che `needp = true` bisognerebbe avere `turn = P` affinché non entri:
				- `needq = false` --> $Q$ deve ancora eseguire `needq = true`, e quindi lo eseguirà dopo l'ingresso di $P$ e porrà `turn = P`, per cui non entra nella CS
			- caso di `turn = P`
		- assenza di deadlock
			- supponiamo entrambi i processi siano nel `while`
			- questo significa che `needp = true`, `needq = true`, `turn = P` e `turn = Q`
			- ma `turn` non può assumere due valori diversi --> assurdo
		- assenza di ritardi non necessari
			- se `Q` ha `needq = false` (non esegue codice critico), allora $P$ può uscire dal `while` ed entrare nella CS
		- assenza di starvation
	- generalizzazione per $N$ processi
		- dimostrazione "per esercizio"
- soluzioni software al [[Problema della sezione critica|problema della CS]]
	- permettono di risolvere il problema, ma sono basate tutte su _busy waiting_ --> spreca il tempo del processore, ed è una tecnica che non dovrebbe essere utilizzata
- soluzioni hardware al problema della CS
	- si può pensare di fornire alcune _istruzioni hardware speciali per semplificare la realizzazione di sezioni critiche_
	- idea: disabilitazione degli interrupt
		- nei single-core i processi concorrenti vengono "alternati" tramite il meccanismo degli interrupt
		- noi prima di entrare nella CS li disabilitiamo! in questo modo non si verrà interrotti da altri processi durante l'esecuzione della CS
		- problemi
			- ma questo non può funzionare su macchine multicore (gli interrupt sono di singoli processori)
			- riduce il grado di parallelismo del processore
			- il S.O. deve lasciare ai processi la responsabilità di riattivare gli interrupt --> è pericoloso
	- istruzioni speciali
		- istruzioni che realizzano due azioni in modo atomico
		- le quasi sezioni critiche realizzate con queste istruzioni sono chiamate _spinlock_
		- **test & set**
			- `TS(x, y) := <y = x; x = 1>`
			- abbiamo aggiunto quest'istruzione composta da due sottoistruzioni che è andiamo a livello hardware a considerarle in modo atomico
			- algoritmo, molto più semplice di Dekker-Peterson
			- c'è mutua esclusione, non c'è deadlock, non c'è delay non necessario MA potrebbe esserci starvation (per l'[[Assioma di finite progress|assioma di finite progress]])
		- ma `test&set` non è l'unica istruzione speciale:
			- `fetch&set`
			- `compare&swap`
		- una funzione tipo `f(x) = <x=x/2, return x>` è utilizzabile come `test&set`
			- si pensi al seguente codice
				- `lock = 2`
				- `do`
					- `l = f(lock)`
				- `while (l != 1)`
				- [enter cs]
				- `lock = 2`
				- [exit cs]
		- vantaggi e svantaggi delle istruzioni speciali hardware
			- c'è ancora busy waiting
			- la starvation non è formalmente eliminata
			- sono comunque complesse da programmare
	- vorremmo dei paradigmi facilmente implementabili e che consentano di scriverei programmi concorrente in modo non troppo complesso
- **semafori**
	- è un paradigma per la sincronizzazione
	- assumiamo di essere in un modello a memoria condivisa
	- fatto da Dijkstra nel 1965 (nello stesso articolo in cui ha esposto l'algoritmo di Dekker!)
	- obiettivo: descrivere un SO come una collezione di processi sequenziali che cooperano
	- principio base: due o più processi possono cooperare attraverso semplici segnali, in modo tale che un processo possa essere bloccato in specifici punti del suo programma finché non riceve un segnale da un altro processo
	- definizione:
		- un semaforo è un tipo di dato astratto per il quale sono definite due operazioni:
			- `V` (dall'olandese _verhogen_) --> invocata per inviare un segnale, quale il verificarsi di un evento o il rilascio di una risorsa;
			- `P` (dall'olandese _proberen_) --> invocata per attendere il segnale (un evento o il rilascio di una risorsa);
	- informalmente:
		- un semaforo è una variabile intera, inizializzata a un valore non negativo
		- `P` attende che il valore del semaforo sia positivo, e se lo è decrementa il valore del semaforo
		- `V` incrementa il valore del semaforo
		- nota bebe: P e V sono atomiche
	- invariante
		- siano $n_{p}$ il numero di operazioni `P` completate
		- siano $n_{v}$ il numero di operazioni `V` completate
		- sia $init$ il valore iniziale del semaforo
		- vale $$n_{p} \leq n_{v} + init$$
		- o equivalentemente $n_{v} + init - n_{p} \geq 0$ sempre: _il valore del semaforo deve sempre essere non negativo_
	- due casi d'uso
		- _eventi_ ($init = 0$)
			- se vogliamo mettere in sequenza dei processi, creando delle dipendenze
		- _risorse_ ($init > 0$)
			- se vogliamo condividere una risorsa inizializziamo il semaforo a 1 (init diventa il numero di risorse)
			- il numero di richieste soddisfatte non deve essere superiore al numero iniziale di risorse + il numero di risorse restituite
	- implementazione di CS
		- dimostrare che viene risolto il problema della CS
	- politiche di gestione dei processi bloccati
		- c'è una cosa non specificata nella definizione di semafori: quando arriva una `V`, quale processo che è in attesa `P` deve "risvegliare"?
		- allora bisogna mantenere una struttura dati che mantenga i processi in sospesi (in attesa)
		- ci sono i **semafori FIFO/fair** che dice: i processi che è stato sospeso più a lungo viene svegliato per primo --> questo garantisce assenza di starvation
			- la struttura dati usata è ovviamente una [[Coda|coda]]
			- sono i semafori più usati
	- implementazione nei sistemi operativi
		- una prima implementazione di `P` e `V`, per evitare [[Race condition|race conditions]] mostruose, avvolge le funzioni in una critical section --> ma se i semafori implementano la CS, allora servirà una CS risolta a livello più basso per poter implementare i semafori!
			- possiamo usare:
				- tecniche software: Dekker, Peterson, ...;
				- tecniche hardware: test&set, swap, ...;
			- in un sistema single-core è possibile anche disattivare e riabilitare gli interrupt all'inizio/fine di `P` e `V`
			- per quelli multi-core servono _spinlock_
		- usando queste tecniche (per implementare i semafori), comunque, non abbiamo eliminato _busy waiting_
			- ma le abbiamo limitate alle CS di `P` e `V`, e queste sono molto brevi
			- quindi la sezione critica non è quasi mai occupata, e il busy waiting avviene raramente
	- vantaggi
	- esempio di utilizzo
		- interleaving senza semaforo;
		- interleaving con semaforo;
	- **semafori binari**
		- possono assumere solo i valori 0 e 1
		- risolvono il problema della CS, ma sono equivalenti ai semafori? possiamo scrivere gli stessi programmi? sì, vedremo che hanno lo stesso potere espressivo dei semafori generali
		- l'invariante diventa: $$0 \leq n_{v} + init - n_{p} \leq 1$$ oppure $$0 \leq s.value \leq 1$$
			- notare: se la prima parte della disuguaglianza vincola `P` (come nei semafori generali), la seconda parte aggiunge il vincolo su `V`, che non può essere fatta se il valore è già 1
		- implementazione nei sistemi operativi
		- implementazione dei semafori generali con semafori binari
	- leggere documento "Decalogo di programmazione concorrente", per capire le cose da non fare per sbagliare un programma concorrente

## Domande

## Referenze
