---
tags:
  - category/lecture
  - status/finished
  - topic/logica-per-informatica
date: 22-11-2023 13:43:05
teacher: claudio.sacerdoticoen@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- [[Ricorsione|ricorsione]] e induzione
	- in matematica
		- in matematica ogni numero è esprimibile usando gli insiemi ([[ZF]])
		- una funzione è un insieme di coppie
			- es. $+ \in \mathbb{N}^{\mathbb{N} \times \mathbb{N}} = ...$
			- di fatto, la maggior parte delle funzioni matematiche non hanno una procedura di calcolo associata
		- in matematica ogni oggetto ha una descrizione infinita
	- in informatica
		- un dato è un qualcosa che ha una descrizione finita
		- l'insieme dei dati è sempre enumerabile
		- un dato di dimensione _unbounded_ (che non ha una dimensione definita a priori) ha sempre una struttura ricorsiva
			- infatti ha delle parti al suo interno che hanno la stessa forma di quella principale
			- la struttura ricorsiva è fondamentale per la definizione di funzioni che prendono un generico dato _unbounded_
				- è obbligatorio, se non avesse una struttura ricorsiva servirebbe un programma di grandezza arbitraria per processarlo
		- un numero è un dato unbounded, infatti è ricorsivo!
			- pensiamo a come si conta con le dita
				- $$\mathbb{N} ::= O \ | \ S \  \mathbb{N}$$
				- "un numero naturale o è lo zero o il successore di un numero naturale $n$"
		- un programma (funzione informatica) descrive una _procedura di calcolo_ per ottenere l'output a partire dall'input
			- esempio per `(S n) + m = S (n+m)`
		- osservazioni
			- un programma $f$ determina la funzione matematica $\{(i, o) | f(i) = o\}$
				- è solo un modo per convertire una funzione matematica in un programma
		- affinché un programma finito possa processare un input di dimensione unbounded è necessario che il codice del programma venga eseguito ripetutamente
			- si può fare con [[Iterazione|cicli]]
			- si può fare con [[Ricorsione|ricorsione]]
		- quando il codice si ripete può rischiare di non terminare: _divergenza_
		- dobbiamo quindi:
			- definire tipi di dati (ricorsivi)
			- descrivere funzioni che lavorano su dati ricorsivi (ricorsione strutturale)
			- dimostrare le proprietà di programmi (induzione strutturale)
	- **ADT**, Tipo di Dato Algebrico
		- definizione/composizione
			- _nome_ del tipo (es. naturale, lista di naturali, coppia)
			- lista di _possibili forme_ (o costruttori) per quel tipo (es. dalla [[Logica proposizionale|logica proposizionale]])
			- può contenere altri dati, specificandone il tipo
			- la _ricorsione_ è ammessa
			- questo ci consente di avere dati finiti ma di dimensione arbitraria
			- ogni valore di un dato 
		- esempi
			- `Booleani`: $\mathbb{B} ::= tt \ | \ ff$
			- `Numeri naturali`: $\mathbb{N} ::= O \ | \ S \ \mathbb{N}$
			- `Liste di numeri naturali`: $\mathbb{L} ::= [] \ | \ \mathbb{N} :: \mathbb{L}$
				- questa è esattamente la forma algebrica che abbiamo visto per dimostrare funzioni ricorsive in programmazione!
				- i $::$ mettono insieme un elemento con una lista, sono l'operatore della concatenazione
			- `Coppie formate da un booleano e un naturale`: $C ::= (\mathbb{B}, \mathbb{N})$
			- anche qui si usano le parentesi per chiarire le strutture del dato
			- così come valgono le associatività (a destra) e le precedenze tra gli operatori
			- `Alberi binari con numeri nelle foglie`: $T ::= \mathbb{N} \ | \ T \cdot T$
			- `Alberi binari con numeri nei nodi interni`: $T' ::= \varnothing \ | \ \mathcal{N}(T', \mathbb{N}, T')$
	- [[Linguaggio di programmazione funzionale|linguaggi di programmazione funzionali]], esempio in [[Haskell]]
		- definizione di funzione
			- $$f(\omega_{1}, x_{1}, ..., x_{m}) = \text{corpo}_{1}$$
			- $$f(\omega_{n}, x_{1}, ..., x_{m}) = \text{corpo}_{n}$$
			- dove:
				- $x_{1}, ..., x_{m}$ sono i parametri formali (come in [[C]]/[[C++]])
				- $\omega_{i}$ è l'$i$-esimo pattern, e corrisponde alla forma di tipo di dato dove si usano parametri formali nelle posizioni per i dati contenuti
				- $\text{corpo}_{i}$ è l'output associato ottenuto da:
					- forme di tipi di dati
					- occorrenze dei parametri formali
					- [[Comandi condizionali|comandi condizionali]], ma attenzioni, non sono comandi `if-then-else`, sono tradotte in espressioni
					- chiamate (ricorsive o no) di altre funzioni
		- quali funzioni $g$ possono essere utilizzate?
			- tutte quelle implementabili e non interessanti, come `+`, `-`, ecc...
			- tutte le funzioni definite precedentemente
			- $g$ può invocare se stessa
		- _pattern matching_ per poter richiamare delle funzioni
			- molto semplice, osservo le due espressioni e se faccio una [[Sostituzione|sostituzione]] ottengo la stessa formula
			- questo serve per la chiamata di funzione
		- chiamata di funzione
			- avviene per pattern matching, a seconda di $\omega_{i}$
		- esempi di funzioni
		- caratteristiche dei linguaggi di programmazione funzionale
			- non ci sono:
				- assegnamenti
				- cicli
				- gestione a basso livello della memoria (per esempio zero gestione dei [[Puntatori|puntatori]])
			- sono linguaggi di programmazione _puri_, ovvero privi di _side effects_
				- perché ci si avvicina alla matematica
				- per esempio, infatti, _manca la randomicità_
			- potenza espressiva
				- indice di quanto un linguaggio di programmazione può risolvere
				- un linguaggio di programmazione abbastanza espressivo raggiunge la **Turing-completezza**
					- questo è il livello di massima espressività
					- se si può risolvere uno stesso problema in più linguaggi, questi sono Turing-completi

## Domande

## Referenze
