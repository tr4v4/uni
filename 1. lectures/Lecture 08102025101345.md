---
tags:
  - category/lecture
  - status/finished
  - topic/basi-di-dati
date: 08-10-2025 10:13:45
teacher: danilo.montesi@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- algebra relazionale
	- ripasso
		- viste / relazioni virtuali
		- viste / relazioni materializzate
	- viste
		- **viste virtuali**
			- tutti i DBMS le supportano
			- fare un'interrogazione su una vista significa fare una query a partire da quella vista --> la vista è in realtà una query
				- semplicemente, _il nome della vista è sostituita nella pratica con la sua query associata_
		- in generale le viste sono utili
			- costituiscono gli _schemi esterni_, e ciascun utente può vedere, di norma, soltanto una vista
				- in SQL, poi, si possono creare delle regole di accesso sulla base dell'autenticazione --> certi utenti possono accedere solo a certe viste
			- sono anche un importante tool di programmazione --> _le query si semplificano molto_, perché si eliminano delle sottoespressioni ripetute
			- interessante notare che non intaccano l'efficienza delle query! Anche se si stackano una sull'altra
		- bisogna fare attenzione agli aggiornamenti sulle viste
			- aggiornare le viste è possibile solo se ci sono abbastanza informazioni per aggiornare le tabelle di base
			- aggiornare una vista significa aggiornare le tabelle di base in modo tale che tali aggiornamenti si riflettano poi nella vista
			- non posso aggiornare la vista e basta!
			- attenzione
				- gli aggiornamenti non devono essere ambigui --> ci devono essere sufficienti informazioni per poter aggiornare le tabelle di base
				- quindi, _solo alcuni, pochi, aggiornamenti, sono consentiti sulle viste_
	- nota sulle join
		- la natural join fa assunzioni sui nomi degli attributi uguali --> a volte non vogliamo che accada che questi attributi siano associati --> disambiguiamo con `RELATION.Attribute`
			- quando questo non basta, possiamo dare delle definizioni a dei nomi di relazioni, in modo da creare nuovi pseudonimi per le tabelle (nuovo nome di `RELATION`)
			- esempio con `CHIEF := EMPLOYEE`
		- un modo un po' naive è quello di rinominare i campi, ma è scomodo
- **calcolo relazionale**
	- basata sulla [[Logica del primo ordine|logica del primo ordine]]
	- due definizioni:
		- calcolo relazionale sui domini
		- calcolo relazionale su tuple con dichiarazioni del range
	- entrambe hanno dei limiti! ce li portiamo dietro in SQL...
	- _calcolo relazionale sui domini_
		- sintassi per fare interrogazione: $\{A_{1}:x_{1}, \cdots, A_{k}:x_{k} | f\}$
			- $A_{1}, \cdots, A_{k}$ sono degli attributi
			- ad ognuna associamo una variabile $x_{1}, \cdots, x_{k}$
			- $f$ è una formula logica, con operatori booleani e quantificatori
		- semantica: il risultato è una relazione sugli attributi $A_{1}, \cdots, A_{k}$ che contiene delle tuple di valori per $x_{1}, \cdots, x_{k}$ che soddisfano la formula $f$
		- esempio:
			- $\sigma_{Wage > 40}(EMPLOYEE)$ diventa $\{Number: m, Name: n, Age: a, Wage: w | EMPLOYEE(Number: m, Name: n, Age: a, Wage: w) \land w > 40\}$
			- $\pi_{Number, Name, Age}(EMPLOYEE)$ diventa $\{Number: m, Name: n, Age: a | \exists w (EMPLOYEE(Number: m, Name: n, Age: a, Wage: w))\}$ o semplicemente $\{Number: m, Name: n, Age: a | EMPLOYEE(Number: m, Name: n, Age: a, Wage: w)\}$
		- valgono le regole di De Morgan
		- pros:
			- dichiarativo
		- cons:
			- è molto verboso
			- ci consente di scrivere espressioni insensate!
				- sono espressioni dipendenti dal dominio
		- equivalenza con algebra relazionale
	- _calcolo relazionale su tuple con dichiarazioni del range_
		- per risolvere i problemi del calcolo relazionale sui domini
		- dobbiamo ridurre il numero di variabili, usando le tuple, una variabile per ogni tupla
		- sintassi: $\{TargetList | RangeList | Formula\}$
			- esempi:
				- $\{e.* | e(EMPLOYEE) | e.Wage > 40\}$
				- $\{e.(Number, Name, Age) | e(EMPLOYEE) |\}$
				- $\{s.Chief | e(EMPLOYEE), s(SUPERVISOR) | e.Number=s.Employee \land e.Wage> 40\}$ 
		- tale calcolo ha comunque dei limiti:
			- non si possono esprimere delle interrogazioni che richiedono l'unione di due altre relazioni
				- possiamo esprimere intersezioni e differenze
				- è implementato su SQL! Quindi le union sono implementate in un modo specifico
		- ...

## Domande

## Referenze
