---
tags:
  - category/lecture
  - status/pending
  - topic/progetto-di-sistemi-virtuali
date: 16-10-2025 09:21:24
teacher: renzo.davoli@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- **sockets**
	- caratteristiche peculiari di un'API socket
	- lo standard lo decide la Berkeley University
		- si deve a questa università la prima `fork` di Unix - una versione universitaria
		- questa versione diventerà BSD
	- il primo esperimento di TCP/IP è un successo
	- a Berkeley si pongono il problema di scrivere programmi per usare la rete --> hanno creato lo standard socket
		- tutto bellissimo, ma c'è solo un errore
	- Berkeley socket
		- è un'_interfaccia_ per comunicazione generale - non solo per TCP/IP, ma per qualsiasi tipo di comunicazione
			- per esempio si adopera Berkeley socket anche per Bluetooth, AX25, ecc...
		- denominatore comune tra tutte le comunicazioni
			- occorre un elemento, descrittore, per individuare il singolo flusso di comunicazione
				- con Unix è stato facile --> si usa un _file descriptor_
				- di fatto, l'oggetto socket che viene creato per gestire una comunicazione è della stessa natura di un oggetto creato quando si fa una `open`
			- bisogna poi indirizzare le entità di comunicazione
				- viene creata quindi l'idea di `sockaddr`, indirizzo di socket
				- è un'idea di generale, diversa per ogni tipo di comunicazione
		- chiamate
			- `socket()` - crea un socket, un endpoint di programmazione per scambiare le informazioni
				- ha 3 parametri
					- `domain` - o anche famiglia, è il tipo di rete al quale vogliamo collegarci - per esempio `AF_INET` è address family internet
						- `AF_UNIX` è per fare [[IPC]], inter-process communication! questo ha come indirizzo un pathname
						- a noi interesserà tantissimo `AF_NETLINK`, è un protocollo che serve per configurare gli stack di rete
					- `type` e `protocol` - individuano all'interno della famiglia il tipo di servizio che si vuole avere
						- `type` - dice che tipo di servizio vogliamo
							- per esempio `SOCK_STREAM`, ossia a tubo --> quindi la comunicazione non è vista a pacchetti dal ricevitore --> se inviamo `a`, `b`, `c`, il ricevitore se legge tanti caratteri legge `abc` tutto insieme
								- invariante: se è stata spedita una sequenza di caratteri, sarà ricevuta tutta la sequenza oppure una sottosequenza! --> da `ciao mare` può arrivare `ciao m`, non `c mar`
								- è [[TCP]]!
							- o anche `SOCK_DGRAM`, ossia la comunicazione avviene a pacchetti, e non c'è sicurezza che i pacchetti vengano recapitati nello stesso ordine, né certezza che vengano tutti recapitati
								- è [[UDP]]
							- o anche `SOCK_SEQPACKET`, è una via di mezzo --> a datagrammi ma sequenziato e affidabile, quindi i pacchetti arrivano in ordine e arriva sempre o l'intera sequenza o un suo prefisso
							- o anche `SOCK_RAW`, è per accedere in modo "grezzo"
							- flags
								- `SOCK_NONBLOCK` - ritorna subito `0` se non c'è niente da leggere al momento della `open`
								- `SOCK_CLOEXEC` - se il file è aperto al momento di una `exec`, viene immediatamente chiuso
						- `protocol` - dipende dal dominio
			- `bind()` - per il server, serve per dare un nome/indirizzo al socket
				- si assegna un `sockaddr` e la sua `socklen
				- `sockaddr`
					- primo campo è la famiglia
					- secondo è l'indirizzo, che cambia a seconda della famiglia --> se è `AF_UNIX` è un pathname da 104 bytes; se è `AF_INET` è un indirizzo IP
				- il bind lega appunto il socket con il suo sockaddr
			- `listen()`, `accept()` per il server
				- `listen()` - "server mettiti all'ascolto di connect da fuori", richiede solo il fd del socket e il backlog, che serve per dimensionare il vettore dell'attesa --> dobbiamo indicare quante richieste di connessione sospese riusciamo a tollerare
					- backlog è effettivamente un rimedio per mitigare il DoS
				- `accept()` - è la chiamata complicata...
					- vita del server: `socket()`, `bind()`, `listen()`, `while (1) accept()`
					- parametri - socket di attesa
					- quando uno fa una connect, la accept crea un altro fd per gestire la connessione separatamente
						- quindi la prima socket serve per la listen
						- la seconda è il fd che serve per parlare con il client che si è connesso
					- di solito quindi dentro il while si fa
						- `comm = accept(s...)`
						- `if (fork() == 0)`
							- `close(s)`, il figlio chiude socket di attesa, di listen
							- gestisce la connessione corrente
						- `else`
							- `close(comm)`, il server chiude il fd del fd restituito da accept
							- torna in cima al loop e si mette in attesa su accept
			- `connect()` per il client
				- ha gli stessi parametri di `bind`, ma bisogna, chiaramente, mettere l'indirizzo dell'altro!
				- client fa: `socket()`, `bind()`, `connect()`
			- `recv()`, `send()`, per usare il fd socket
				- ma essendo un fd, si possono tranquillamente usare le syscall standard, come `read()` e `write()`
				- `send()` con campo `flags` a 0 è identico a una `write`
				- `sendto()`, `sendmsg()`
	- peer-to-peer vs. client-server
		- peer-to-peer
			- in Berkeley socket basta che tutti i peer facciano `bind` (chiaramente su una famiglia che supporta il peer-to-peer, come UDP)
		- client-server
			- in Berkeley socket entrano in ballo le altre chiamate
- ioth
	- permette di creare un nuovo stack di rete
	- e al posto della socket c'è la ioth_socket, uguale alla socket ma con un parametro in più

## Domande

## Referenze
- `strace`