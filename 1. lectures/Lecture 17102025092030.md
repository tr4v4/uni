---
tags:
  - category/lecture
  - status/pending
  - topic/progetto-di-sistemi-virtuali
date: 17-10-2025 09:20:30
teacher: renzo.davoli@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- dettaglio mancante sui socket
	- perché è così importante il fatto che `socket()` lavori con un file descriptor?
		- perché possiamo redirezionare per esempio l'output di un comando su un `SOCK_STREAM` e inviarlo quindi in rete o ad altri processi (IPC)
- vuos - continuo
	- `vudev`
		- i device sono dei file speciali, nella directory `/dev`
		- se li guardiamo sono solo dei "simulacri"
		- all'interno c'è solo l'i-node, e all'interno ci sono due numeri che identificano il device
			- il _major number_ individua il device o il driver;
			- il _minor number_ è una precisazione all'interno del device/driver;
		- quando si fa la `open` il kernel si accorge che è un file speciale
		- la directory `/dev` è un filesystem virtuale che cambia ogni volta che si aggiunge/toglie un device
		- per virtualizzare un device
			- occorre virtualizzare
				- system call
				- `ioctl` - ogni driver ha i suoi comandi `ioctl` e le sue funzionalità
					- parametri
						- `fd` del file aperto come device
						- `tag` che dice cosa fare
						- terzo argomento che dipende dal secondo e dal primo
		- ora vudev
			- possiamo creare dentro umvu un file che è un ramdisk device, quindi tutto ciò che scriviamo su quel file in realtà finisce in ram
			- a questo punto l'host non ha accesso a quel file, quindi è un grande meccanismo di protezione --> solo quella "macchina virtuale" può vederlo e scriverci sopra
			- quando si fa unmount viene liberato
		- fuori dall'ambiente vuos bisogna essere root per fare un sacco di cose con dei filesystem
			- mount per esempio, ma anche mkfs...
			- e root può essere pericoloso
			- invece usando vudev siamo all'interno di una macchina che cattura tutte le syscall, e lavoriamo semplicemente con dei file che sono montati senza root come filesystem (usando fuse)
		- `vudevpartx` - per creare partizioni
			- raspberry pi
				- ha una piccola partizione FAT per il boot, il firmware legge solo FAT
				- poi ha root, in ext4
			- `vudevpartx` è in grado di gestire sia MBR che GPT
	- `vufs`
		- questo modulo consente di prendere un pezzo (sottoalbero) del filesystem e dire "questo lo voglio vedere in quest'altro path"!
		- posso quindi spostare sottoalberi del filesystem, far sparire sottoalberi del filesystem
		- per esempio:
			- voglio far apparire `/var` sotto `/mount`
			- allora faccio `vumount -t vufs /var /mnt`
		- 4 modalità di funzionamento
			- _bind_ (default) - collega questo a quello
			- _merge_ - vogliamo far comparire l'unione delle due directory
			- _cow_ - come merge, ma se si fanno delle modifiche, vengono fatte sulla partizione che avete montato
			- _mincow_ - tutte le operazioni prova a farle sul fs reale --> se riesce a farle le fa normali, altrimenti fa cow (copy-on-write)
	- `vunet`
		- porta la parte di networking fuori dal kernel
		- dentro vuos
			- monto uno stack e creo un device che lo rappresenta
			- il tipo di file stack non esiste! quindi compare come `weird file`
			- con `ip addr` per ora non cambia niente, ma se faccio `vustack /dev/net/x ip addr` ecco che vede l'altro stack, virtualizzato!
			- quindi per usare slirp basta poi fare `/sbin/udhcpc -i vde0` da dentro la bash di `/dev/net/x`
	- questo moduli fuori dal server assomigliano molto a server di microservizi dei [[Microkernel|microkernels]]!
		- quindi **`vuos` potrebbe diventare il giusto compromesso tra kernel monolitici e microkernel**!
- con ioth teniamo il programma invariato e possiamo farlo funzionare su implementazioni di stack diversi cambiando solo una stringa --> questo ha superato l'idea di avere moduli specifici
- cambiamo ordine mentale: adesso scriviamo programmi C che devono interfacciarsi alla rete, non più comandi
- **ioth**
	- idea
		- normalmente i processi che usano la rete in un sistema linux usano le berkeley socket e dialogano attraverso quindi le syscall --> kernel!
		- lo stack TCP/IP è concettualmente un layer --> verso l'alto parla berkeley socket, verso il basso con i bit per l'interfaccia di rete
		- possiamo quindi prendere questo layer e trasformarlo in una libreria!
		- il punto è: con chi dialoga verso il basso?
			- con direttamente dei device?
			- magari no! meglio una rete virtuale!
		- quindi l'applicazione carica lo stack come libreria e si interfaccia tramite `vde_plug` con reti vde
		- questo produce effetti positivi sulla sicurezza --> layer in più per proteggere le reti virtuali
			- è come dire: invece che accedere direttamente a una rete, metto un router che collega la mia a quella a cui mi voglio connettere
		- quindi ioth parla con reti virtuali, poi se serve si può attaccare alla rete reale
			- per esempio con `tap`
	- funzionamento
		- il codice che andiamo a scrivere si scrive usando `libioth`, che fa da interfacciamento dello stack `ioth`
			- attraverso una stringa possiamo tranquillamente scegliere l'implementazione dello stack
		- per creare uno stack usiamo `ioth_newstack`, sintassi simile a quella della famiglia di comandi `exec`
			- primo parametro: stringa dello stack
			- secondo parametro: rete virtuale a cui vogliamo connetterla
		- anche `ioth_delstack`
		- problema: non esiste una libreria C per dire "voglio cambiare indirizzo IP"
			- ci sono solo dei comandi, come `ip addr ...`
		- nota
			- `ifconfig` è deprecato perché usa `ioctl` per parlare con il kernel
				- quindi non è capace di gestire indirizzi IPv6
			- `ip addr`, quello nuovo, usa le socket! in particolare `NETLINK`, che serve per comunicare con il kernel riguardo alla configurazione delle reti
				- vediamo cosa fa usando `strace`...

## Domande

## Referenze
