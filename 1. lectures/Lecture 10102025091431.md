---
tags:
  - category/lecture
  - status/pending
  - topic/progetto-di-sistemi-virtuali
date: 10-10-2025 09:14:31
teacher: renzo.davoli@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- esperimento VLAN
	- vogliamo creare 2 VLAN e poi una "logica", ossia che è un'interfaccia fisica ma la macchina virtuale può scegliere se attaccarla logicamente alla prima o alla seconda VLAN, con la proprietà tag
		- untagged - senza etichetta, è il pacchetto normale senza l'header 802.1q
			- quindi una porta untagged è gestita dallo switch in modo che `0 untagged`, per esempio, appartenga comunque alla VLAN `0`
			- è lo switch che aggiunge l'header!
		- tagged - viene aggiunto l'header 802.1q, l'host sa di appartenere a una certa VLAN
			- non è supportato da tutte le macchine
	- di VLAN se ne possono fare 8191 con 802.1q --> ma c'è a chi non bastava!
	- allora è nato 802.1ad, anche detto q-in-q, ma è abbastanza scomodo
	- hanno quindi pensato di fare un altro protocollo
		- rete degli switch sono come supporto, e virtualizzare sopra le VLAN
		- `vxlan`
			- le macchine virtuali su una macchina fisica parlano con quest'ultima usando il VTEP (Virtual Tunnel End-Point)
			- bisogna collegare i vari VTEP tra di loro --> _si incapsulano i frame Ethernet dentro un segmento UDP_!
			- IP multicast
				- da `224.0.0.0` a `239.255.255.255` sono indirizzi multicast
				- chiunque si registri a questi indirizzi riceve pacchetti inviati a questi indirizzi
			- VTEP
				- internamente si comporta come uno switch normale
				- altrimenti lo inscatola in un segmento UDP verso un indirizzo IP multicast!
				- quindi tutti i VTEP lo ricevono, e se anche loro non sanno nulla lo inoltrano, espandendo il segnale multicast
				- ...
				- si comporta come uno switch distribuito sulle varie macchine
				- l'overhead è basso
			- ma si può fare di meglio! A cosa serve VTEP?
				- `vxvde`
				- meglio, perché si parla end-to-end
	- in poche parole, `vxvde` consente di creare una rete virtuale locale per interconnettere macchine virtuali su macchine fisiche diverse
- **VUOS**
	- in VDE avevamo le macchine virtuali come sistema di virtualizzazione, che parlavano e scambiavano informazioni usando Ethernet
	- in VUOS virtualizziamo le system call!
	- vogliamo fare un hypervisor che sia in grado di parlare il linguaggio delle system call dando risposte che ci consentono di creare prospettive diverse sull'ambiente di esecuzione
	- es.: `umvu bash`
		- vengono catturate tutte le syscall dei processi e `umvu` le reindirizza al kernel
		- è un layer in più
		- l'obiettivo è di non inoltrare per forza le richieste al kernel! Il processo chiama le syscall, ma queste sono intercettate da umvu e possono essere giocate come si vuole
	- usermod linux
		- è nata proprio virtualizzando TUTTE le system call! Infatti in questo modo non c'è assolutamente nessuna differenza con una macchina virtuale!
		- non si trova il codice, perché è esattamente quello di Linux!
		- è solo che il codice è compilato in user mod!
		- il kernel diventa un processo
		- la differenza con le macchine virtuali è fondamentale: i processi sono runnati sulla macchina fisica, e SOLO le syscall sono catturate da usermod linux!
		- il file system è comunque quello della macchina virtuale però
	- l'idea di VUOS: non voglio avere una macchina virtuale completa! Magari voglio sono cambiare, virtualizzare, alcune funzionalità
		- voglio una _macchina virtuale parziale_
	- funzionamento
		- per moduli
			- es.: modulo di virtualizzazione delle reti, del tempo, di qualunque cosa!
			- `vu_insmod vumisc`
				- `xclock -update 1 &`
				- `mount -t vumisctime none /mnt`
			- `vu_insmod unreal`
				- virtualizza il filesystem della macchina host
				- accedo alla macchina reale, ma le informazioni sono date dalla macchina virtuale!
				- è un modo per testare se lo stack di virtualizzazione funziona
	- fuse - filesystem in user-space
		- consente agli utenti di montare filesystem come utenti
		- perché mount è solo root!
		- ma se creo un file e ci metto un filesystem con `mkfs.ext2`, per esempio, allora per quale motivo non dovrei poterlo montare come utente?? E' un mio file!
		- allora usiamo `fuse2fs /tmp/disk /tmp/mnt`
		- ma per farlo è il kernel a dare supporto a fuse: crea `/dev/fuse`
	- VUOS consente di fare la stessa cosa di fuse, ma al di fuori dal kernel!
		- la sintassi è compatibile con fuse --> è un fuse virtuale
		- `vu_insmod fuse`, è `fuse` ma implementato all'interno della macchina virtuale, non dal kernel!
		- per intenderci, `/tmp/mnt` è vuoto nella macchina fisica, mentre in `umvu` contiene il mount di `/tmp/disk`
		- in breve virtualizziamo file system montati
	- `archivemount`
	- `sshfs`
		- `sshfs dominio:/directory /mnt`
		- e poi `umount /mnt` per chiudere
		- o se si è dentro un'istanza `umvu`, `vuumount /mnt`
			- in tal caso il `/mnt` è vuoto nella macchina reale!
	- `vunet`
		- virtualizzare la rete
		- chi l'ha detto che dobbiamo avere un solo stack di rete?
		- il fatto che ci sia un solo stack di rete è dovuto all'unica syscall chiamata `socket`
			- prossima volta facciamo i moduli socket con calma... grazie a Dio
		- `vu_insmod vunet`
		- `vumount -t vunetnull none /dev/net/null`
			- si potrebbe usare `mount`, ma questo è stato implementato male e ha un controllore che non ti fa fare nulla se non sei superuser
		- `vustack /dev/net/null bash`, potenziale con `exec` prima
			- se si vuole testare un programma senza avere il timore che vada in rete a fare cose...

## Domande

## Referenze
