---
tags:
  - category/lecture
  - status/finished
  - topic/sistemi-operativi
date: 13-03-2025 15:17:45
teacher: renzo.davoli@unibo.it
mod: 2
---
# Lezione
---
## Concetti
- **deadlock**
	- teorema che lega i knot al grafo Holt per rilevare deadlock
	- ma dopo aver rilevato il deadlock, bisogna risolverlo --> **deadlock recovery**
		- modalità
			- manuale
			- automatico
		- ad ogni modo, si può fare
			- terminazione totale, vengono eliminati tutti i processi
			- terminazione parziale, viene eliminato un processo alla volta finché non si risolve il deadlock
		- si può fare anche checkpoint/rollback --> lo stato dei processi viene periodicamente salvato su disco, e in caso di deadlock si ripristina ad uno stato precedente
			- non sempre è possibile, i programmi possono avere effetti esterni (anzi è molto comune)
		- considerazione
			- terminare un processo può essere costoso
			- terminare processi può lasciare le risorse in uno stato incoerente (per esempio viene terminato un processo nel mezzo di una sezione critica)
	- possiamo allora provare a usare tecnologie di deadlock prevention o avoidance
		- _prevention_ --> tolgo la possibilità strutturale che si possa creare un deadlock, eliminando una delle quattro condizioni del deadlock
		- _avoidance_ --> prima di assegnare una risorsa ad un processo si controlla se l'operazione può portare al pericolo di deadlock (e in tal caso l'operazione viene rimandata)
	- **deadlock prevention**
		- attacchiamo la condizione di _mutua esclusione_
			- si usa _spool_ o _spooling_
				- esempio: quando si parla con la stampante non si parla realmente con la stampante, ma con una sua versione virtuale sempre disponibile; e quando la stampante reale si libera, quella virtuale manda tutto il documento in un colpo solo
				- alla fine è un buffer
			- problemi dello spooling
				- in generale non è sempre applicabile (come nei descrittori di processi)
				- si sposta il problema verso le altre risorse
		- attacchiamo la condizione di _richiesta bloccante_
			- possiamo usare l'allocazione totale, ossia allocare tutte le risorse necessarie a un processo all'inizio della computazione --> se sì parte, se no no
			- problemi
				- non sempre è noto l'insieme di richieste sin dall'inizio
				- si riduce il parallelismo
		- attacchiamo la condizione di _assenza di prerilascio_
			- non è sempre possibile
			- può richiedere interventi manuali
		- attaccare la condizione di _attesa circolare_
			- si può usare l'allocazione gerarchica
				- alle classi di risorse vengono associati valori di priorità
				- ogni processo in ogni istante può allocare solamente risorse di priorità superiore a quelle che già possiede
				- se un processo vuole allocare una risorsa a priorità inferiore, deve prima rilasciare tutte le risorse con priorità uguale o superiore a quella desiderata
			- così facendo rendo impossibile creare cicli, e quindi anche knot
			- problemi: l'indisponibilità di una risorsa ad alta priorità ritarda processi che già detengono risorse ad alta priorità
	- **deadlock avoidance**
		- _algoritmo del banchiere_, fatto da Dijkstra
			- un banchiere ha del capitale, che vuole condividere con un numero prefissato di clienti
			- ogni cliente specifica la sua necessità massima di denaro (che non deve superare il capitale del banchiere)
			- i clienti fanno due tipi di transazioni
				- richieste di prestito
				- restituzioni
			- il denaro prestato ad ogni cliente non può mai eccedere la necessità massima specificata a priori dallo stesso cliente
			- ogni cliente può fare richieste multiple, fino al massimo importo specificato
			- ogni volta che le richieste sono state accolte e il denaro è stato ottenuto deve garantire la restituzione in un tempo finito
			- funzionamento: il banchiere dev'essere in ogni istante in grado di soddisfare tutte le richieste dei clienti, o concedendo il prestito o sospendendo la richiesta rimandando la sua soddisfazione in un secondo momento
			- parametri:
				- $N$ numero di clienti
				- $IC$ capitale iniziale
				- $c_{i}$ limite di credito del cliente $i$
				- $p_{i}$ denaro prestato al cliente $i$
				- $n_{i} = c_{i} - p_{i}$ credito residuo del cliente $i$
				- $COH = IC - \sum\limits_{i=1}^{n} p_{i}$ (saldo di cassa)
			- definizione: _stato safe_
				- è una sequenza dove si consente di valutare se la situazione attuale può consentire a tutti i processi di terminare
				- tra i vari processi ce ne dev'essere almeno uno che ha $n_{i} = 0$ --> così può finire e restituire i soldi (le risorse) al banchiere
				- formalmente, data una sequenza di risorse $s$ (permutazione di risorse da $1$ a $N$), calcoliamo il vettore $avail$ come
					- $avail[1] = COH$
					- $avail[j+1] = avail[j] + p_{s(j)}$ con $j = 1, \cdots, N-1$
				- allora uno stato del sistema si dice safe se vale $$n_{s(j)} \leq avail[j] \ \ \ j=1, \cdots, N$$
			- nota bene: lo stato unsafe non è sinonimo di deadlock! ma potrebbe capitare, per cui si vuole mantenere la safeness
			- regola pratica (per il banchiere a singola valuta): si usa una sequenza che ordina in modo crescente i valori di $n_{i}$
		- ovviamente l'_algoritmo del banchiere reale è quello multivaluta_ --> non esiste una solo classe di risorse
			- l'applicazione è abbastanza naturale --> da scalare passiamo a vettoriale
		- c'è un teorema importante: se durante la costruzione della sequenza $s$ si giunge ad un punto in cui nessun processo risulta soddisfacibile, allora l'intero stato NON è safe! --> non esiste alcuna sequenza che consenta di soddisfare tutti i processi
			- dimostrazione per assurdo
				- supponiamo che lo stato sia safe, ovvero che esista la sequenza che consente di soddisfare tutti i processi
				- sia $C$ la sequenza interrotta, e $C'$ la sequenza che porta allo stato safe
				- prendiamo $H = \{p \in processi | p \notin C\}$, e $h$ il primo elemento di $H$ che compare in $C'$
				- tutti gli elementi di $C'$ prima di $h$ compaiono in $C$, allora chiamiamo $C''$ il segmento iniziale di $C'$ fino al punto precedente ad $h$
				- ...
		- l'algoritmo del banchiere funziona ed è ottimale, ma ha un solo problema: bisognerebbe conoscere per ogni processo tutte le risorse che vorrà usare, e non è banale
		- _algoritmo dello struzzo_
- **gestione della memoria**
	- deve
		- tenere traccia della memoria libera e occupata
		- allocare memoria ai processi e deallocarla quando non più necessaria
	- binding (già fatto in linguaggi)
		- chi lo fa?
			- durante la compilazione
				- gli indirizzi sono calcolati al momento della compilazione e resteranno gli stessi ad ogni esecuzione del programma --> il codice generato viene detto _assoluto_
				- è facile e veloce, ma non funziona con la multiprogrammazione
					- due processi che eseguono lo stesso programma diventa una situazione impossibile
				- il kernel è in codice assoluto
			- durante il caricamento
				- ogni indirizzo durante il caricamento viene traslato sulla base dell'indirizzo di partenza su cui viene allocato --> il codice si chiama _rilocabile_
				- permette di gestire multiprogrammazione e non richiede hardware particolare, ma richiede di tradurre tutti gli indirizzi da parte del loader
			- durante l'esecuzione
				- il compilatore compila in codice assoluto, e il loader non aggiunge nessun offset (il caricamento non cambia il codice) --> ogni volta che il processo genera l'indirizzo, interviene la MMU a run-time che trasforma l'indirizzo logico in indirizzo fisico!
	- indirizzi logici e fisici

## Domande

## Referenze
