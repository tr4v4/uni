---
tags:
  - category/lecture
  - status/finished
  - topic/ingegneria-del-software
date: 29-09-2025 10:35:33
teacher: giancarlo.succi2@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- moduli e sub-system
	- sub-system
		- fanno una task specifica o un insieme di responsabilita' (approccio procedurale); insieme di classi (approccio OO)
		- es.: [[DBMS]]
	- modulo
		- piu' specifico al linguaggio
		- insieme o libreria di funzioni che fanno una task specifica (approccio procedurale); oppure classi (approccio OO)
- astrazione, information hiding
	- interfaccia vs. implementazione
		- accedo ad un modulo tramite l'interfaccia, e non ne tocco l'implementazione --> quest'ultima puo' anche essere diversa, ma mantenendo l'interfaccia costante il comportamento semantico non cambia (cambiano le procedure per ottenere il risultato)
	- il concetto e' l'astrazione
	- l'implementazione e' il codice
- dobbiamo dividere il codice in porzioni il meno interdipendenti possibili --> _low coupling_
	- avere 0-coupling e' impossibile, dividere il codice in funzionalita' e' un miraggio!
	- bisogna pero' cercare di organizzare il codice in parti tra di loro coese, autodipendenti, e che siano il meno connesse possibili con il resto
	- una dipendenza e' per forza necessaria
		- una funzione/metodo che chiama una funzione/metodo
		- accoppiamento di strutture dati
		- sottoclassi
			- grande mito: con gerarchie di classi si riducono i costi di produzione
			- si e' scoperto empiricamente invece che la presenza di grandi gerarchie di classi produce una sostanziale incomprensione di quello che succede
				- ereditarieta'
				- funzioni virtuali e non virtuali
			- insomma dopo tot. livelli di ereditarieta' il programma diventa illeggibile
			- GO e Rust (pseudo-oggetti) ha abolito l'ereditarieta' per questo
			- Java ha l'ereditarieta' singola! (solo 1 superclasse)
		- un modulo fa uso di una feature di un compilatore o di una syscall del sistema operativo --> assolutamente da non fare!
- il duale del low coupling e' l'_alta coesione_
	- devo organizzare i moduli in modo tale che quello che e' dentro un modulo serva per ottenere un goal specifico
	- livelli crescenti di coesione
		- coincidentale - elementi messi insieme senza ragione
		- logica - connessione di funzionalita'
		- temporale - connessione temporale, certa funzionalita' eseguita subito prima o subito dopo un'altra --> molto usata nei sistemi operativi
		- procedurale - legata ai sistemi di memoria segmentata ([[Segmentazione]])
		- comunicazionale
		- sequenziale
		- _informazionale_
		- _funzionale_
- quindi basso accoppiamento e alta coesione
- _semplicita'_
	- si pensava che: quando sviluppo una classe devo anticipare le funzionalita' che saranno richieste in futuro --> design for reuse, ossia progettarlo anche un po' piu' complicato in modo tale da gestire evoluzioni future
	- ma questo e' un errore!
		- si rischia di implementare funzionalita' che non saranno mai richieste
		- si spreca tempo, e si rende piu' complesso il codice
	- NON ANTICIPARE FUNZIONALITA'
	- invece fare _refactoring_ - modifica del codice che ne migliori la qualita' ma non ne alteri la funzionalita'
		- sara' piu' facile nel futuro debuggarlo, adattarlo a usi futuri
		- codice semplice piu' facile ad essere modificato nel futuro
	- ma a che livello semplicita'?
		- a livello di metodo - piccoli metodi con piccole firme;
		- a livello di modulo - piccola interfaccia pubblica;
		- a livello di sistema
			- evitare moduli "middle-man"
			- poche variabili globali
			- minimizzare le informazioni condivise
			- gerarchie piu' piccole possibili
		- a tutti i livelli, evitare di duplicare il codice!
- **UML**
	- devo modellizzare i sistemi software
	- usiamo il linguaggio di modellazione
	- a che pro?
		- e' un linguaggio unico, somma di 3 linguaggi, comune a tutti
	- UML per formalizzare le principali idee di OO
	- OO
		- come faccio a rappresentare il mondo in un modello che possa essere falsificato
		- e' un modo per vedere il mondo dell'applicazione, per descrivere il modello dell'applicazione
		- ci concentriamo sui modelli a oggetti perche' sono strumenti per ottenere alta qualita' tramite
			- information hiding
			- astrazione
			- modularizzazione
			- riuso
		- forza lo sviluppatore a pensare cosi'!
	- modello OO
		- oggetti
		- attributi
		- relazioni
	- concetto di
		- classe
		- oggetto/istanza
		- messaggi/metodi
	- modello di processo OO
		- e' ciclico, in continua comunicazione con il cliente
		- si definisce per iterazioni
	- classe
		- e' una collezione di oggetti simili
		- identifica attributi degli oggetti della classe e i suoi comportamenti (metodi)
		- istanziazione di una classe
		- i libri di testo dicono che la comunicazione tra oggetti avviene per message passing
		- simbolo in UML
	- ereditarieta'
		- quando una classe estende un'altra classe
		- simbolo in UML
		- ereditarieta' multipla
	- polimorfismo
		- ricordiamo che con l'overriding e' fatto in late binding
	- l'UML e' descritto con l'UML!
		- meta-meta-linguaggio
		- i classifiers sono: _classe, interfaccia, datatype, componente, nodo, use case, subsystem_
		- ha piu' di 9 tipi di diagrammi
			- alcuni _strutturali_ - descrivono la struttura dei sistemi software
			- altri di _comportamento_ - descrivono il comportamento di sistemi software
	- modellamento dei concetti
		- ossia come analizzo il contesto e i requisiti di un sistema
		- e' la famosa **analisi dei requisiti**
		- andiamo a _modellare il concetto di un sistema tramite gli use-case_
		- per poter descrivere un sistema software e' impossibile descriverlo (se complesso) tramite la descrizione del sistema come input/output
			- bisogna cercare di raccogliere delle "storie" di funzionamento --> user stories
			- raccolgo quello che il mio sistema deve fare
		- "non posso conoscere la realta' guardandola da fuori"
		- use case contiene:
			- _attori_
			- _descrizioni testuali_
		- uno use-case descrive quindi un'interazione tra un attore e un sistema, ossia uno scenario d'uso
			- deve avere una caratteristica: _dare un valore atomico all'utente finale_
			- valore perche' deve dare un'interazione con l'utente
			- atomico per farlo in modo chiaro
		- quindi definire lo use case e' la prima cosa che vado a fare -> ogni sistema deve dare qualcosa di discreto e utile all'utente finale
		- nello sviluppo di uno use-case, domande da farsi
		- attori
			- ruolo dell'utente
			- non devono per forza essere esseri umani!
			- deve ottenere un valore concreto e atomico dallo use case
		- relazioni nello use case, usano nomi confusi
			- `extends` - uno use case e' simile a un altro ma fa un po' di piu'
				- per ogni step ci si deve chiedere
					- cosa potrebbe andare storto?
					- come potrebbe funzionare diversamente?
				- e quindi si estende con i casi limite lo use case per ogni variazione possibile
			- `includes` - ci sono alcune parti condivise nel comportamento tra piu' use cases
				- serve per ridurre la duplicazione di comportamenti di use case diversi

## Domande

## Referenze
