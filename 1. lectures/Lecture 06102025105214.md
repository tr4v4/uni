---
tags:
  - category/lecture
  - status/finished
  - topic/ingegneria-del-software
date: 06-10-2025 10:52:14
teacher: giancarlo.succi2@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- ripasso
	- differenza tra istanziazione e derivazione (generalizzazione)
		- istanziare --> crea oggetto
		- derivare --> crea sottoclasse
- come stabilisco il criterio di appartenenza a una classe (di un oggetto)
	- 2 modelli
		- implicito - se un certo oggetto ha un certo nome, appartiene a una classe
			- per esempio, le JUnit, o il package di Java
		- esplicito per enumerazione - dichiarando il tipo dell'oggetto, automaticamente lo associo ad una classe
	- è possibile a runtime che un oggetto cambi classe?
		- in UML è possibile, in C++/Java si fa con il polimorfismo
		- in C era già possibile con i puntatori void
- generalizzazione
	- estensione o restrizione
	- estensione, modo standard, la sottoclasse eredita tutto dalla superclasse
	- restrizione, difficile da realizzare nei linguaggi
- è anche possibile pensare di vedere una piccola percentuale di una classe molto grande
	- l'idea una volta era di creare delle macro classi, e poi di accedere a delle _prospettive_ di quelle classi
	- sono stati creati detti AOP, che facevano proprio questo, ma non li usa nessuno
- ereditarietà multipla
	- le gerarchie di sovrappongono, per questo non è spesso implementato...
	- il problema si pone quando una classe eredita da due classi che a loro volta vengono dalla stessa radice!
	- per questo è nata l'_ereditarietà virtuale_
		- non ha niente a che vedere con le funzioni virtuali
		- serve per disambiguare il caso precedente
		- le derivazioni virtuali ereditano un'unica copia della superclasse (è un po' come static...)
	- come la evito allora, dato che è scomoda? come penso al mio modello?
		- ci sono intanto linguaggi a oggetti che non hanno ereditarietà, come Go
		- e poi posso usare altre tecniche --> _delegation & aggregation_
			- posso mettere insieme aggregazione e delega
				- ricordiamo che aggregazione è il contenimento
- consigli per la creazione dei diagrammi di classe
	- partire nel modo più semplice possibile
- nota bene: il progetto finisce quando il cliente smette di pagarci, o si arriva alla data di scadenza
	- non possiamo, inoltre, farci guidare dal progresso tecnologico --> dobbiamo rimanere semplici quando sviluppiamo software --> quanta più complessità metto, tanto più è complesso
- dall'analisi al design
	- ricordiamo che è un processo ciclico
	- 5 temi
		- _scomponibilità_ - come posso scomporre un problema grande in tanti sottoproblemi più semplici da risolvere
			- non sempre è possibile farlo!
				- [[Divide et impera]] dei romani, ha funzionato soltanto in una battaglia (orazi e pugliazzi...) per Albalonga
			- presuppone quindi che un problema possa essere scomposto
			- per questo dobbiamo prendere il problema non nella sua generalità
		- _componibilità_ - poter crescere, iterazione dopo iterazione, un sistema fino a renderlo più ampio
			- questo è uno dei motivi per cui occorre essere semplici nel design del sistema
		- _comprensibilità_ - il sistema dev'essere leggibile, la miglior documentazione è il codice scritto bene
			- dopo debugging di solito non si aggiorna la documentazione...
		- _continuità_ - il codice va prodotto in modo incrementale
		- _protezione_ - il codice va prodotto in modo protetto --> eventuali errori non si devono propagare
			- torna il low coupling
			- nei sistemi operativi si ha alto coupling --> per esempio la variabile condivisa `errno`
	- OOA a OOD (analisi -> design)
	- distinzioni? aumento il livello di dettaglio
	- ho ancora i diagrammi delle classi, ma sono raffinati per dare riferimento al design del sistema
		- in più ho:
			- diagrammi strutturali
			- diagrammi comportamentali
			- diagrammi a componenti (ma non li guardiamo)
	- **diagrammi strutturali**
		- contengono diagrammi a classi e a oggetti 
	- **diagrammi comportamentali**
		- diagrammi di interazione
			- mostrano come un oggetto interagisce con gli altri oggetti
			- metto gli attori e gli oggetti in alto
			- poi delle righe verticali per ogni attore e oggetto, parallele tra loro
			- azioni:
				- sincrone - freccia completa
				- asincrone - mezza freccia
					- non blocca il chiamante
			- noi facciamo riferimento ai diagrammi di sequenza
		- diagrammi di stato
			- dimostrano come un oggetto evolve nel suo stato, e possa cambiare stato
			- stato
				- definizione: quelle caratteristiche che permettono di definire in modo univoco il comportamento di un oggetto
				- ossia il valore dei campi
				- nota: non tutti i campi sono fondamentali per definire lo stato... sono solo le caratteristiche rilevanti
			- in UML
				- _entry_ - azione da fare quando si entra in quello stato
				- _do_ - attività da fare per tutta la durata dello stato
				- _on_ - azione da fare in un certo evento
				- _exit_ - azione da fare quando si esce
			- un evento può avere una guardia (`if`)
			- differenza tra azione ed evento
				- azione fatta da un oggetto
				- evento qualcosa che può avvenire
		- diagrammi di attività
			- servono a descrivere il workflow
			- simili alle reti di Petri
			- struttura
				- fork
				- join
				- condizioni

## Domande

## Referenze
