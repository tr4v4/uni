---
tags:
  - category/lecture
  - status/pending
  - topic/sistemi-operativi
date: 04-04-2025 09:27:28
teacher: renzo.davoli@unibo.it
mod: 2
---
# Lezione
---
## Concetti
- **memoria virtuale**
	- algoritmi di rimpiazzamento - continuo
		- LRU approssimato
			- second-chance algorithm
				- le pagine in memoria sono gestite come una lista circolare
				- l'idea è semplice: è come se fosse FIFO ma se la pagina è stata acceduta (reference-bit a 1) allora gli dà una seconda possibilità
				- se tutte le pagine sono a 1, allora essendo una lista circolare torna alla prima considerata e avrà il bit a 0 --> degenera in FIFO
				- proprietà fondamentali:
					- facile da implementare
					- minimo supporto della MMU
		- LFU
			- si mantiene il contatore del numero di accessi, ma questo si divide per il tempo di permanenza in memoria --> è una frequenza
			- la pagina con minore frequenza viene scelta come vittima
			- non è il massimo
	- allocazione
		- algoritmo di allocazione (per memoria virtuale) --> è un algoritmo usato per scegliere quanti frame assegnare ad ogni singolo processo
		- allocazione locale --> ogni processo ha un insieme di frame;
		- allocazione globale --> tutti i processi allocano tutti i frame nel sistema (sono in competizione); porta a _trashing_;
			- trashing: un processo è in trashing se spende più tempo per la paginazione che per l'esecuzione
			- è causato dal fatto che i processi chiedono frame nuovi (liberi) e quindi la memoria primaria non riesce a tenere i frame utili, e quindi ci sono page fault spessissimo
			- non dobbiamo assolutamente aggiungere processi se la CPU è libera (ready queue vuota), perché probabilmente tutti i processi sono in page fault --> peggioreremo la cosa
			- dobbiamo stimare la quantità di frame necessari a un processo per poter operare tranquillamente --> _working set_
				- c'è trashing quando mentre aspetto una pagina un altro processo me la fotte
				- dopo aver fatto questa stima per tutti i processi, vedo se la somma delle pagine necessarie è superiore al numero di frame totali --> se sì stiamo per andare in trashing
				- come funziona: si stima il futuro guardando il passato
				- in particolare si usa una finestra $\Delta$ (dove $\Delta$ è un numero): insieme di pagine accedute dei più recenti $\Delta$ riferimenti; è come la località della cache
				- per esempio, in una finestra di 5 guardiamo le pagine accedute dai processi (è un insieme, non ci sono ripetizioni); allora si stima l'ampiezza della finestra, ossia quanti frame sono stati acceduti in $\Delta$ riferimenti alle pagine, ad ogni istante di tempo passato
				- alla fine il working set è la somma dell'ampiezza della finestra $\Delta$ (ossia del numero di frame "utili", "utilizzati") per tutti i processi
				- funzionamento: ogni volta che un processo vuole essere eseguito e quindi allocare frame, se ci si accorge che si sta andando in trashing --> stimando il working set, allora il processo si sospende
- **memoria secondaria** e **sistemi di I/O**
	- i sistemi di I/O classificabili in
		- modalità di trasferimento: caratteri (es. tastiera) o blocchi (es. disco)
			- blocchi
				- dati scritti in blocchi
				- si può accedere in
					- raw I/O
					- tramite file system
					- tramite memory-mapped
		- modalità di accesso: sequenziale (es. sempre tastiera) o random
		- trasferimento: sincrono (flusso continuo di dati) o asincrono (se non viene usato non c'è flusso di dati, la comunicazione tace)
		- condivisione: dedicato o condivisibile
		- velocità
		- direzione di I/O: sola lettura o sola scrittura
	- gestione dei dispositivi
		- buffering --> per dispositivi lenti non si trasmette una cosa alla volta, si bufferizzano le cose e poi si trasferiscono per rendere le cose più veloci
		- caching
		- spooling
		- I/O scheduling
	- **memoria secondaria**
		- SSD
		- dischi rotazionali
			- un disco è composto da un insieme di piatti, suddivisi in tracce, le quali sono suddivise in settori
			- parametri fondamentali:
				- r: la velocità di rotazione, espressa in rpm (revolutions per minute)
				- $T_{s}$: il tempo di seek, ovvero il tempo medio necessario affinchè la testina si sposti sulla traccia desiderata
				- $V_{r}$: la velocità di trasferimento, espressa in byte al secondo
			- tempo di accesso: tempo necessario per leggere un settore del disco, composto da tempo di seek, ritardo rotazionale e tempo di trasferimento;
			- ritardo rotazionale: tempo medio necessario affinchè il settore desiderato arrivi sotto la testina --> $\frac{1}{2r}$
			- transfer time: dipende dalla quantità di dati b da leggere (supponendo che siano contigui sulla stessa traccia) --> $\frac{b}{V_{r}}$
			- **disk scheduling**
				- bisogna minimizzare le seek, quindi soddisfare le richieste pendenti per il disco in modo da minimizzare le seek
				- FCFS
					- non minimizza il numero di seek, ma non può mai generare starvation
				- SSTF
					- seleziona le richieste vicine, che prevedono il minor spostamento della testina dalla posizione corrente
					- ma questo può provocare starvation
				- LOOK, o algoritmo dell'ascensore
					- alla testina viene associato un verso: salita o discesa
					- soddisfa tutte le richieste del verso corrente, poi quando sono soddisfatte tutte quelle di tale verso, si inverte e si soddisfano quelle del verso opposto
					- è efficiente, ma sono privilegiate le tracce centrali
					- per risolvere la starvation viene fatto con 2 code:
						- una per le richieste in salita
						- una per quelle in discesa
					- in questo modo, infatti se si è al cilindro $x$ e arrivano richieste per $x$ ulteriori, queste sono messe nella coda opposta, e si evita starvation
				- C-LOOK, o algoritmo della macchina da scrivere
					- è come il LOOK ma ha un solo verso, e torna indietro quando è alla fine
		- **RAID**
			- problema: i processori vanno sempre più veloci (legge di Moore), mentre i dischi no
			- possiamo usare un sistema che parallelizzi i dischi per accederci in modo più veloce
			- si fa un array di dischi per distribuire le richieste tra i vari dischi
			- quindi i dati non sono salvati in modo sequenziale tra i dischi (prima si riempie il 1°, poi il 2°, ecc...), ma ripartiti in modo da consentire l'accesso sequenziale --> dal punto di vista del sistema operativo il disco visualizzato è uno solo
			- consiste in 7 schemi che rappresentano diverse architetture di distribuzione dei dati
			- il punto è che sappiamo che più dischi ci sono più è alta che tutta la memoria secondaria si guasti (si sommano le probabilità) --> dobbiamo velocizzare l'accesso ma cercare di diminuire anche i rischi --> per questo RAID usa meccanismi di parità
			- ovviamente il bus deve tollerare la maggiore velocità di accesso con RAID, altrimenti le performance non migliorano complessivamente
			- _RAID 0_ (striping)
				- sarebbe AID, perché non c'è ridondanza
				- i dati del disco logico vengono suddivisi in strip, e gli strip consecutivi sono su dischi diversi, e questo aumenta le performance della lettura dei dati sequenziali
			- _RAID 1_ (mirroring)
				- la ridondanza è ottenuta duplicando tutti i dati su due insiemi indipendenti di dischi
				- il sistema è su striping ma lo strip viene scritto su due dischi diversi (e non 4)
				- è ridondante, ma al massimo sostiene la rottura di due dischi dello stesso "lato del mirror"
				- il costo per unità di memorizzazione raddoppia
			- _RAID 4_
				- usa sempre striping con strip grandi, ma poi si accosta un disco che contiene gli strip di parità
				- si fa uno XOR bit a bit di tutti gli strip dei dischi e si mette il risultato nello strip corrispondente del disco di parità
				- per leggere è ottimo, ma per scrivere è stupido: bisogna scrivere nel disco effettivo e ricalcolare lo XOR nel disco di parità
			- _RAID 5_
				- è come il 4, ma anche la parità viene messa ciclicamente nei vari dischi
				- non esiste quindi un disco di parità che diventa un bottleneck
			- _RAID 6_
				- come il 5, ma si usano due strip di parità invece che uno
				- ora è necessario che si guastino 3 dischi per perdere effettivamente i dati
- **file system**
	- composto da: file e directory
	- file
		- collezione di informazioni correlate, entità atomica di assegnazione/gestione della memoria secondaria

## Domande

## Referenze
