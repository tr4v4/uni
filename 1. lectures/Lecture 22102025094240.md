---
tags:
  - category/lecture
  - status/pending
  - topic/basi-di-dati
date: 22-10-2025 09:42:40
teacher: danilo.montesi@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- SQL basic
	- join
		- abbiamo che il costrutto `NATURAL JOIN`
		- ricordiamo, su join c'è condizione, su natural join bisogna avere l'attributo in comune
		- _outer join_
			- sono introdotto per rispondere all'esigenza di non dover perdere il contenuto di una delle due tabelle (o entrambe) nel caso in cui ci siano tuple senza corrispondenza
			- in SQL si può omettere `OUTER`, e quindi scrivere tipo `LEFT/RIGHT/FULL JOIN`
		- schema delle join
			- ![[sql-joins.png]]
	- `ORDER BY ... ASC/DESC`
		- anche qui SQL fa qualcosa in più dell'algebra relazionale o del calcolo relazionale
	- `UNION`
		- visto che SQL deriva dal calcolo su tuple, in cui non è possibile fare le unioni, bisogna usare una sintassi particolare: `SELECT ... UNION [ALL] SELECT ...`
		- i risultati delle righe sono unici, a meno che non si usi l'opzione `ALL`
		- è importante la notazione posizionale
			- se le due tabelle hanno schema diverso, dovremmo risolvere il conflitto... quello che fa SQL è sbattersene dei nomi per le union, e considerare solo le posizioni, prendendo i nomi dello schema del primo operando (prima tabella)
	- `EXCEPT`
		- è la differenza, con sintassi: `SELECT ... EXCEPT SELECT ...`
	- `INTERSECT`
		- è l'intersezione
	- **query annidate**
		- abbiamo la `SELECT FROM WHERE`, e all'interno della condizione della clausola `WHERE` possiamo mettere delle sottoquery (altre `SELECT`)
		- questioni
			- sono meno dichiarative - si distaccano un po' dall'algebra...
			- ma sono un po' più leggibili, e sono in linea con il principio [[Divide et impera]]
		- attenzione all'=, >, <, ... --> ci vogliono costrutti diversi per casi in cui la query annidata è una relazione e non un singolo valore
			- ci sono `ANY` e `ALL` in questi casi, [[Quantificatori]] universali
			- sintassi: `Attribute op ANY/ALL(Expr)`
			- c'è anche `IN`, con sintassi `Attribute IN(Expr)`
			- `ANY`, `ALL` e `IN` possono combinarsi con `NOT`
			- equivalenze:
				- `A IN(Expr)` $\equiv$ `A = ANY(Expr)`
				- `A NOT IN(Expr)` $\equiv$ `A != ALL(Expr)`
		- si vede come il calcolo diventa per passi... più "iterativa"
		- limiti delle query annidate - _regole di visibilità_
			- non è possibile riferire delle variabili dichiarate da sottoquery
			- fondamentalmente, quindi, i blocchi di sottoquery hanno un loro [[Scope]]
			- infatti, i blocchi interni possono vedere le variabili del blocco esterno!
		- semanticamente, la query interna è generata per ogni tupla della query esterna --> possiamo risolvere con le viste
		- le query si possono annidare in `WHERE` (standard), ma anche in `FROM` e addirittura in `SELECT`
	- `EXISTS`
		- quantificatore esistenziale
		- `EXISTS(Expr)` è vero se esiste almeno una tupla all'interno della relazione `Expr`
		- di solito sono usate in query annidate, dopo la clausola `WHERE`
	- funzioni di aggregazione
		- sono `COUNT | MIN | MAX | AVG | SUM`, posti nella _target list_, ossia dopo la `SELECT`
		- `COUNT`
			- `SELECT COUNT([DISTINCT] */Attribute)`
			- non conta i campi `NULL` --> il valore nullo non è considerato un valore contabile
		- `AVG`
			- anche qui il valore nullo non viene preso in considerazione
		- `MAX`
			- attenzione: questo aggrega!
			- `SELECT Name, MAX(Income) FROM PEOPLE` ti associa a tutti i nomi il reddito massimo tra tutti i redditi? --> errore!
				- la target list tutti i tipi di attributi uguali!
			- `SELECT MIN(Age), MAX(Income) FROM PEOPLE` va bene invece
		- `GROUP BY`
			- ci sono casi in cui vogliamo che le funzioni aggregate siano applicate a sottogruppi di righe della tabella
			- `GROUP BY` raggruppa di una certa tabella i valori di uno o più attributi
			- sintassi: `GROUP BY AttrList`
			- semantica:
				- prima esegui la query senza opzione di aggregazione
				- poi esegui il group by raggruppando in base ai valori dell'attributo specificato
				- poi applica l'operatore (eventualmente) `COUNT` sui sottogruppi
			- anche qui attenzione ai vincoli --> la target list deve avere tipi di attributi uguali
				- di solito il nome del/i campo/i raggruppato/i e l'operatore di aggregazione (come `COUNT`)
			- condizioni sui gruppi
				- si possono fare usando `HAVING`
				- di solito `HAVING` è seguita da condizioni su una funzione di aggregazione (es. `HAVING AVG(Income) > 25`)
				- attenzione alla differenza con `WHERE`!
					- `WHERE` - si applica sulle singole tuple
					- `HAVING` - si applica sui gruppi di tuple formate dal `GROUP BY`
			- con valori `NULL`

## Domande

## Referenze
