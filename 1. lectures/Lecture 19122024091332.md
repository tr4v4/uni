---
tags:
  - category/lecture
  - status/pending
  - topic/sistemi-operativi
date: 19-12-2024 09:13:32
teacher: renzo.davoli@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- **MultiPandOS**, **phase 2**
	- consegnare fase 1 in `/home/students/LABSO/2025/submit_phase1/lso25az20`
	- scaricare la nuova versione di uriscv, necessaria per la fase 2 (ha multiprocessing) --> usare comando `reinstall`, non `install`
	- parti:
		- _inizializzazione del kernel_;
		- _scheduler dei processi_, _gestione dei processi_, ciclo di vita;
		- _gestione delle eccezioni e delle `SYSCALL`_;
		- _gestione degli interrupt_;
		- _gestione del passaggio di eventi_ (per livello 3);
	- schema del kernel
	- ci sono 8 processori, il kernel è esso stesso un programma concorrente
		- bisognerà evitare le _race conditions_
		- inoltre sullo stesso processori ci può essere _multiprogramming_, ossia più programmi eseguiti in alternanza (parallelismo apparente)
	- il processo corrente è eseguito finché:
		- non fa una system call;
		- termina;
		- il timer dello scheduler scade e genera un interrupt;
		- un device interrompe;
	- se lo scheduler scopre che la coda dei processi ready è vuota:
		- `HALT` - se non ci sono altri processi da runnare;
		- `WAIT` - aspetta un'operazione I/O da completare, che sbloccherà un PCB e popolerà la coda dei processi ready;
	- **inizializzazione del kernel**
		- dichiarazione di _Process Count_, _Ready Queue_, _Current Process_, _Device semaphores_, _Global Lock_
		- popolazione del _Processors Pass Up Vector_, ossia il gestore dell'evento _TLB-Refill_ e delle eccezioni
		- inizializzazione delle strutture dati di fase 1
		- inizializzazione di tutte le precedenti variabili dichiarate
		- caricamento dell'_Interval Timer_ con 100 millisecondi
		- instanziamento del processo test
		- _Interrupt Routing_
		- impostazione dello stato per l'altra `NCPU` (1 CPUs)
		- invocazione dello _Scheduler_
	- **Scheduler**
		- intanto, il nucleo deve garantire _finite progress_, per cui tutti i processi devono prima o poi essere eseguiti --> il kernel deve implementare un semplice _preemptive round-robin scheduling algorithm_ con un tempo di slice di 5 millisecondi
		- fondamentalmente, quando lo scheduler è avviato deve prendere il prossimo processo in attesa nella coda dei processi ready, e poi:
			- rimuovere il PCB dalla testa della Ready Queue e salvare il puntatore del PCB nel campo del Current Process della CPU;
			- impostare a 5 millisecondi il Processor's Local Timer;
			- performare un Load Processor State nel processor state salvato nel PCB del Current Process;
		- quindi, dovrà farlo passare da stato "ready" a stato "waiting"
		- se la Ready Queue è vuota:
			- Process Count = 0 --> invoca istruzione/servizio del BIOS `HALT`;
			- Process Count > 0 --> entra nello stato `WAIT`;
	- le eccezioni si dividono in:
		- **eventi TLB-Refill** (MMU)
			- verrà fatta in fase 3
			- quindi se avvengono eccezioni di questo tipo si deve passare il controllo a gestori implementati in fase 3
		- **eventi Eccezioni** (parte grossa di fase 2)
			- ogni volta che avviene un eccezione, la macchina va a vedere l'indirizzo della funzione da noi passato, invocandola con uno stack nuovo
			- verrà salvato nel `BIOSDATAPAGE` lo stato del processore prima dell'esecuzione della funzione associata all'eccezione --> sono informazioni importanti
			- nel primo processore c'è l'indirizzo specificato di questa memoria, per gli altri usiamo una macro fatta da loro
			- per vedere da cosa è causata l'eccezione bisogna andare a vedere su `Cause` nel `BIOSDATAPAGE` (sul processore su cui è avvenuta)
				- ci sono varie cause, una tra queste è `SYSCALL`
			- **SYSCALL**
				- si invoca chiamando la funzione `SYSCALL`, in cui passare parametri per specificare che tipo di system call invocare e i suoi parametri
				- system calls, quelle del kernel identificati da interi negativi (sono sensibili, sono in kernel-mode):
					- `CREATEPROCESS` (la prima che dovremmo andare ad implementare), crea processo come figlio del padre che richiama questa system call;
					- `TERMINATEPROCESS`, se `pid` specificato è 0 si ammazza il processo chiamato, altrimenti ne ammazza un altro
					- `PASSEREN`, esegue una `P` su un semaforo
					- `VERHOGEN`, esegue una `V` su un semaforo
					- `DoIO` (la più complessa), per fare operazioni di input/output, che in MultiPandOS è sincrono (il processo che la richiede viene bloccato), semplificata assegna il valore del comando all'indirizzo del dispositivo, ma non è così semplice:
						- va gestito l'accesso concorrente allo stesso dispositivo (`P` sul semaforo del processo associato all'accesso al dispositivo, per mutua esclusione (`mutex`));
							- l'interrupt che sblocca il processo fa una `V`;
						- nota importante: scrivere il comando nel registro del device PRIMA di chiamare lo scheduler, altrimenti si verificano casini di race condition e da debuggare è impossibile
					- `GETCPUTIME`
					- `WAITFORCLOCK`, necessaria per aspettare il prossimo tick dello "pseudo-clock" di sistema, ogni 100 ms --> sospende il processo fino al prossimo tick
					- `GETSUPPORTDATA`, una riga di codice
					- `GETPROCESSID`
				- se un processo in user-mode invoca una system call kernel-mode, viene invocata una Program Trap
				- quando una system call finisce:
					- se è non-bloccante, alla fine della system call viene ripreso il servizio che si stava eseguendo in quel momento --> attenzione all'indirizzo del program counter, perché una volta terminata la syscall si ha proprio l'indirizzo della syscall stessa nel PC, bisogna andare avanti di 4;
					- se è bloccante, stesso discorso dell'andare avanti di 4, e bisogna inoltre salvarsi lo state del processo interrotto, e poi chiamare lo scheduler (non ritorniamo il processo appena bloccato, perché è tornato nella ready queue)
			- **Interrupt**
				- interrupt timer
				- interrupt causato da dispositivi
				- più interrupt allo stesso momento? se ne gestisce uno alla volta
					- vai a vedere i bit dell'interrupt e uno alla volta (quelli accesi) lo gestisci --> vai a vedere, si chiama, la _maschera degli interrupt_
				- PLT interrupt, ogni 5 millisecondi switcha i processi nello scheduler, per alternarli evitando che uno sia eseguito sempre
					- il processo "running" può:
						- terminare;
						- transizione da "running" a "blocked", eseguire la SYSCALL 3, 5 e 7;
						- essere interrotto dal PLT interrupt;
					- in caso di PLT interrupt, ci sono delle operazioni da fare
				- oltre al PLT ci sono altri 2 timer:
					- Interval Timer - quello usato dalla `WAITFORCLOCK`, per implementare lo pseudo-clock
					- TOD, counter che conta da 0 a infinito, ogni clock aumenta incrementa TOD (non c'è sulle slide)
				- l'interrupt scatenato dall'Interval Timer deve gestire alcune cose
			- **Pass Up Vector** e **Pass Up or Die**
				- per passare la gestione di interrupt non gestiti da fase 2, ma da fase 3
				- tra tutte queste eccezioni, dette General Exception, rientrano le syscall con valori positivi
				- tra queste ci sono anche le Program Trap
			- **3 timer di uriscv**
				- sono:
					- TOD - Time Of Day, l'unico che va in avanti
					- Interval Timer, parte da 100 millisecondi a 0
					- PLT, parte da 5 millisecondi e va a 0
				- solo gli ultimi due possono generare eccezioni
	- testing

## Domande

## Referenze
