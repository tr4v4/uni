---
tags:
  - category/lecture
  - status/ongoing
  - topic/basi-di-dati
date: 16-10-2025 15:16:51
teacher:
mod: 2
---
# Lezione
---
## Concetti
- DBMS architecture
	- è un software che crea e gestisce database
	- è un modo efficiente per gestire una quantità ingente di dati
	- è efficiente, persistente
	- uno relazionale deve
		- memorizzare tabelle
		- eseguire query SQL
	- architettura
		- ![[architettura-dbms-relazionale.png]]
		- **query processor**
			- è composto da
				- _query compiler_
					- fa
						- _parsing_
						- _preprocessing_
						- _optimization_
				- _execution engine_
					- esegue tutti gli step dell'espressione in algebra relazionale in uscita dal compilatore
					- recupera le informazioni dal manager delle risorse
		- **manager delle risorse**
			- i dati di un database sono sempre su una memoria secondaria, claro
			- si compone di
				- _index/file/record manager_ che conosce lo schema del database
				- _buffer manager_ che partiziona la memoria principale in buffer dentro i quali possiamo trasferire dei blocchi di disco (fa da cache)
				- _storage manager_ che tiene traccia delle locazioni dei file sul disco, e ottiene i blocchi
		- **transaction manager**
			- sono necessarie le [[Transazione|transazioni]] per eseguire blocchi di istruzioni SQL atomicamente
			- ogni transazione è isolata dalle altre
			- la durabilità di un DBMS: il lavoro di una transazione non sarà mai perso; e nel caso in cui in mezzo alla transazione si "staccasse la corrente", il DBMS torna allo stato subito precedente alla transazione
			- gestisce
				- _logging and recovery_ - segno su un file separato le operazioni che faccio
					- inizialmente il Log Manager scrive sui buffer, e poi una volta che la transazione è andata a buon fine vengono scritti su disco
					- il Recovery Manager esamina i log changes e ripristina il database a uno stato consistente
				- _concurrency control_ - deve assicurare che le azioni di tutte le transazioni abbiano lo stesso effetto sia che io le esegua in parallelo sia che le esegua una alla volta
					- lo facciamo tramite un meccanismo di _lock_
					- quando due query accedono alla stessa tabella, viene appunto creato un lucchetto che fa passare una transazione alla volta
					- incredibile, si crea [[Deadlock|deadlock]] anche qui
						- il Transaction Manager deve intervenire e cancellare (rollback o abort) una o più transazioni per far procedere le altre
						- se cancello una transazione libero il deadlock, ma devo fare il rollback delle operazioni fatte dalla transazione!
	- operazioni di join
		- è un problema: estremamente complesso computazionalmente
		- 4 tecniche comuni:
			1. nested-loop join
			2. single-loop join
			3. sort-merge join
			4. hash-based join
- **transazioni**
	- un programma è una sequenza di letture e scritture
	- una transazione è l'esecuzione di un programma utente che contenga una o più operazioni di lettura e scrittura
	- problemi
		- esecuzione concorrente di transazioni
			- vogliamo far eseguire più transazioni contemporaneamente, in modo concorrente, per tenere la CPU occupata
		- crash recovery
			- un crash potrebbe interrompere una transazione, lasciando il database in uno stato inconsistente
	- proprietà ACID delle transazioni
		- _Atomicity_ - una transazione è un'unità atomica
			- casi di aborto della transazione
				- anomalia interna
				- condizioni di eccezione
				- crash di sistema
			- attraverso i file di log si possono fare i rollback, implementando l'atomicità, e anche garantire la durabilità (ultima proprietà)
		- _Consistency_ - tutte le transazioni devono mantenere la consistenza del database
			- assicurata dall'utente
		- _Isolation_ - ogni transazione deve apparire come se nessun'altra transazione stia eseguendo nello stesso momento
			- garantito dal fatto che quando finisco di eseguire le query (in parallelo) il risultato è uguale al risultato che avrei avuto eseguendole in serie
			- le transazioni non sono eseguite in un ordine preciso, garantito! Perché è lo scheduler che decide l'ordine
		- _Durability_ - una volta che la transazione è avvenuta, i cambiamenti devono essere commitati, e non devono essere mai persi per nessuna ragione
			- garantita sempre dai file di log
	- consistenza
		- assumiamo che il developer abbia definito dei vincoli di integrità
		- una transazione allora:
			- parte dallo stato consistente
			- potrebbe passare attraverso stati inconcistenti
			- deve tornare allo stato consistente
		- nota bene: lo stato di un database sono le tabelle e i dati che lo compongono
		- quindi, o faccio rollback per qualche motivo, e lo stato è consistente; oppure completo la transazione e quindi sono in uno stato inconsistente
			- invariante: il database è sempre in uno stato consistente!
	- schedule
		- ogni transazione deve specificare l'azione finale:
			- _commit_ - è andato tutto bene
			- _abort_ - c'è stato qualcosa che non va, oppure ho deciso di terminare la transazione
		- uno schedule $S$ è una sequenza di azioni (read, write, commit e abort) presa da un insieme di transazioni
		- l'ordine dello schedule è lo stesso delle transazioni corrispondenti --> esecuzione cronologica delle transazioni
		- gli schedule possono avere le seguenti proprietà
			- _completi_ - includono commit o abort per ogni transazione
			- _seriali_ - per ogni transazione, tutte le operazioni sono eseguite consecutivamente (non si interrompono) --> una transazione in esecuzione alla volta
		- schedule serializzabile
			- ha lo stesso effetto di uno schedule completo e seriale
		- conflitti di esecuzioni interleaved
			- conflitto write-read
			- conflitto read-write
			- conflitto write-write
		- anomalie phantom
		- transazioni abortite
		- parametri delle transazioni
		- livello di isolamento
	- approcci per controllare la concorrenza
	- tutto il lucido, e vaffanculo

## Domande

## Referenze
