---
tags:
  - category/lecture
  - status/finished
  - topic/linguaggi-di-programmazione
date: 17-09-2024 11:06:11
teacher: roberto.gorrieri@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- esame
	- diviso in scritto e orale, da fare nella stessa sessione
	- per l'orale c'è una lista di domande possibili (PDF)
	- ci sono i parziali
		- parziale 1 (fine mod. 1): mercoledì 8 gennaio 2025, 10:00-12:30 e 13:00-15:30
		- parziale 2 (fine mod. 2-3) (per accedere il voto del primo parziale >=16): fine maggio 2025
- obiettivi del corso
	- "Computer Science is no more about computers than Astronomy is about telescopes" - Dijkstra
	- cos'è un linguaggio, come si definisce, cos'è la semantica?
	- "A Good Programming Language is a Conceptual Universe for thinking about Programming" - Perlis
	- è necessario conoscere decine di linguaggi diversi? Basta conoscere i meccanismi comuni a centinaia di essi!
		- quindi competenza trasversale sui LP
		- non ci interessa studiare un singolo linguaggio, ma una panoramica sull'intera gamma dei linguaggi
- programma del corso
	- mod. 1
		- evoluzione dei linguaggi di programmazione
		- macchine astratte, interpreti, compilatori
		- compilatori: struttura generale
		- come descrivere un linguaggio: sintassi, semantica, pragmatica
		- sintassi (BNF) e semantica (tecnica SOS)
		- grammatiche regolari, automi a stati finiti, espressioni regolari: equivalenze e risultati principali
		- scanner: costruzione di analizzatori lessicali
		- grammatiche libere da contesto, automi a pila: equivalenze e risultati principali
		- grammatiche libere deterministiche: algoritmi di riconoscimento e costruzione dell'albero di derivazione
		- parser: costruzione di analizzatori sintattici
		- fondamenti: esistono vincoli che un compilatore non può verificare; proprietà indecidibili; Macchine di Turing
	- mod. 2
		- nomi
		- gestione della memoria
		- strutturare il controllo
		- astrarre sul controllo
		- parametri e modalità di passaggio
		- strutturare i dati
		- astrarre i dati
		- paradigma orientato agli oggetti
		- cenni al paradigma funzionale
		- cenni al paradigma logico
		- cenni alla programmazione concorrente e service-oriented
- libri:
	- mod. 1: linguaggi di programmazione - principi e paradigmi (scritto da Martini e Gabbrielli!)
	- mod. 2: programming languages: principles and paradigms
	- complementari: Compilatori - Principi e tecniche; Introduction to automata theory languages and computations
- argomento: **evoluzione dei linguaggi di programmazione**
	- anni 50-60: compilazione dei programmi per ottenere efficienza; connessione diretta fra hardware e linguaggi (integers, reals, goto); "programmers cheap, machines expensive -> keep the machine busy"
	- oggi: compilazione di programmi costruiti in modo efficiente; connessione diretta fra software design e linguaggio (encapsulation, records, ereditarietà, dichiaratività); "programmers expensive, machine cheap -> keep the programmer busy"
	- evoluzione
		- anni 40-50, preistoria: linguaggio macchina e assembler
		- anni 50-60, primi linguaggio ad alto livello
			- _FORTRAN_ per calcolo numerico-scientifico, uso di notazione matematica in espressioni
			- _ALGOL_ come linguaggio universale, per esprimere algoritmi: indipendenza dalla macchina, vicinanza con la notazione matematica, call by name, funzioni ricorsive, type systems, strutture dati (anche dinamiche)
			- _LISP_ per l'intelligenza artificiale (List Processor): funzioni su una certa classe di espressioni simboliche, ordine superiore (proto-paradigma funzionale)
			- _COBOL_ per applicazioni commerciali (record, archivi)
			- _ALGOL 68_ linguaggio barocco, complessa progettazione ma contiene la nuova idea della struttura a blocchi
			- _SIMULA_ da ALGOL primo linguaggio con classi e oggetti (proto-paradigma orientato a oggetti)
		- anni 70:
			- _PL/I_ è FORTRAN + COBOL, primo linguaggio multi-uso
			- _PASCAL_ evoluzione e semplificazione di ALGOL W, didattico fino agli anni 80 (poi rimpiazzato da C e Java), portabile grazie a codice intermedio
			- _C_ programmazione di sistema (Unix), notevole successo
			- _Prolog_ usa esplicitamente la logica come base di un linguaggio di programmazione (primo linguaggio logico)
			- _SmallTalk_ primo vero linguaggio orientato a oggetti
			- _ML_ primo verso linguaggio funzionale
		- anni 80:
			- _ADA_ primo linguaggio real-time concorrente, notevole successo
			- _Postscript_
			- _C++_
			- _Standard ML_
			- _CLP_ linguaggio logico con vincoli
		- anni 90 (nasce Web!):
			- _Java_ altamente portatile (elevata portabilità per JVM e ByteCode!), object-oriented, programmi spediti su rete
			- _PERL_ linguaggio per text-processing
			- _HTML_
			- _XML_
		- anni 2000:
			- service-oriented computing, paradigma che usa i servizi come unità di base di computazione per progettare applicazioni integrate di business
			- _WSDL_
			- _WS-BPEL_
			- _Jolie_ sviluppato a Bologna!
	- **differenze tra categorie di linguaggi**
		- imperativi
			- basati sulla nozione di _stato_ del programma, composto dalle variabili
			- le istruzioni sono comandi che modificano lo stato del programma
			- esempi: C, Pascal, FORTRAN, COBOL
		- dichiarativi
			- basati sulla nozione di _funzione_ o _relazione_
			- le istruzioni sono dichiarazioni di nuovi valori
			- esempio `(fun(x). x+2) 3;`
			- due sottoclassi
				- funzionali
					- basati sulla nozione di funzione: il risultato del programma è il valore esplicito di una espressione
					- il costrutto base è la ricorsione
					- programmare = costruire la funzione che calcola il risultato
				- logici
					- basati su relazioni, ossia il risultato è il valore di alcune variabili determinato da alcune relazioni logiche
					- le istruzioni sono le implicazioni logiche tra le variabili
		- orientati a oggetti
	- **come confrontare i linguaggi**
		- caratteristiche instrinseche
			- _espressività_: Turing-completezza!
			- _didattica_: quanto sono semplici le primitive del linguaggio e quanto velocemente lo si può apprendere
			- _leggibilità_
			- _robustezza_: capacità del linguaggio di prevenire errori di programmazione (es. tipato)
			- _generalità_: facilità nel codificare algoritmi e soluzioni a problemi in campi diversi
			- _efficienza_: di solito quelli più ad alto livello sono lenti, viceversa per quelli a basso livello
		- caratteristiche esterne
			- _diffusione_: per la community e quindi il materiale
			- _standardizzazione_
			- _integrabilità_
			- _portabilità_
	- **macchine astratte, interpreti e compilatori**
		- macchine astratte e linguaggi
			- macchina fisica
				- ripasso [[Architettura di von Neumann]]
					- [[Ciclo di fetch-decode-execute]]: lettura istruzione, decodifica istruzione, lettura valore degli operandi, esecuzione dell'istruzione, memorizzazione del risultato
					- programmi e dati risiedono entrambi nella memoria
				- morale: una _macchina fisica_ esiste per eseguire il _suo linguaggio_
			- macchina astratta
				- è come una macchina fisica: ha sua memoria, sue operazioni
				- ma tra le operazioni e la memoria ci sono:
					- controllo sequenza
					- controllo dati
					- gestione memoria
				- questa traduzione è gestita dall'_interprete_
				- interprete
					- operazioni per l'elaborazione dei dati primitivi
					- operazioni e strutture dati per il controllo della sequenza di esecuzione delle operazioni (per la macchina fisica è il PC e i salti)
					- operazioni e strutture dati per il controllo del trasferimento dei dati (per la macchina fisica è la gestione dell'indirizzamento)
					- operazioni e strutture dati per la gestione della memoria (per la macchina fisica era l'indirizzamento)
			- linguaggio macchina
				- se $M$ è una macchina astratta, allora $L_{M}$ è il linguaggio macchina di $M$
				- $L_{M}$ è il linguaggio compreso dall'interprete di $M$
				- parentesi sul linguaggio macchina hardware
					- filosofie [[CISC e RISC]]
					- tipica istruzione a due operandi in [[Notazione prefissa]] (`ADD R5 R0` e `ADD [R5] [R0]`)
					- l'"interprete" della macchina hardware esegue
						- operazioni primitive (operazioni aritmetico logiche, ecc...)
						- controllo sequenza (salti, ecc...)
						- controllo dati
						- gestione memoria
					- possiamo dire che un processore convenzionale è una macchina astratta molto concreta (concretissima), con un suo linguaggio macchina che è quello hardware
					- attenzione: alcune macchine hardware sono microprogrammate, ossia ogni istruzione $\in L_{MF}$ è realizzata in istruzioni di più basso livello dette $\mu$-istruzioni (micro-istruzioni) interpretate di un $\mu$-interprete (micro-interprete)
						- quindi un programma in $L_{MF}$ è interpretato da un interprete e a sua volta eseguito da un micro-interprete
			- realizzazione macchina astratta
				- in 3 modi
					1. realizzazione in _hardware_; teoricamente sempre possibile ma usata solo per macchine di basso livello, massima velocità, poca flessibilità --> NO
					2. emulazione o simulazione via _firmware_ --> NO
					3. interpretazione via _software_; minore velocità ma massima flessibilità --> SI'
		- gerarchie di macchine astratte e di linguaggi
			- ogni macchina astratta può basarsi su una macchina astratta di livello più basso e fare da base (offrire primitive e servizi) a una macchina astratta di livello più alto
			- nota bene: il livello 0 è quello hardware!
		- implementare un linguaggio: interpreti e compilatori
			- scartiamo la soluzione hardware assimiliamo software e firmware
			- dati: un linguaggio $L$ da implementare, cioè di cui realizzare la macchina astratta $M_{L}$; una macchina astratta $MO_{LO}$ con il suo linguaggio $LO$
			- notazione:
				- $P_{r}^{L}$ è un programma $P_{r}$ scritto nel linguaggio $L$
				- a $P_{r}^{L}$ è associata una funzione parziale $P^{L}$ che ad ogni input al programma associa un output
					- è una funzione parziale perché su certi input non è definito un output
			- _implementazione interpretativa pura_
				- si scrive un interprete per $L$ su $MO_{LO}$ (immagine)
				- l'interprete lo scrivo in $LO$, il linguaggio usato ed eseguito da $MO$
				- formalmente un interprete per $L$, scritto in $LO$ è un programma che realizza una funzione parziale $$I_{L}^{LO} : (P_{r}^{L} \times D) \to D \ \ : \ \ I_{L}^{LO}(P_{r}^{L}, D) = P^{L}(D)$$
				- scarsa efficienza della macchina $M_{L}$, perché la decodifica di un body di un ciclo viene eseguita tante volte quanto il ciclo
				- tuttavia è flessibile, più facile da realizzare, occupa meno memoria
			- _implementazione compilativa pura_
				- i programmi in $L$ sono tradotti in programmi equivalenti in $LO$
				- il compilatore $C^{LA}_{L,LO}$
				- più formalmente un compilatore da $L$ a $LO$ è un programma che realizza una funzione $$C_{L,LO}: Pr^{L} \to Pr^{LO} \ \ | \ \ \forall P_{r}^{L} \ C_{L,LO}(P_{r}^{L})=P_{r}c^{LO} \implies \forall D \ P^{L}(D) = Pc^{LO}(D)$$
				- difficile, data la lontananza tra $L$ e $LO$, scarsa flessibilità e perdita di info sulla struttura del programma (un errore run-time è poco facile da identificare, per questo C dà pochi suggerimenti sugli errori)
				- tuttavia è molto efficiente
			- caso reale
				- di solito coesistono le componenti, di solito prima compilazione e poi interpretazione su un livello meno astratto
				- esempio Java
					- inoltre viene usata la JIT (Just-In-Time) Compilation, ossia la compilazione avviene run-time, quindi è un misto della AOT (Ahead-Of-Time) Compilation e l'interpretazione
			- si possono sempre realizzare interpreti e compilatori, dato una macchina ospite?
				- il compilatore preserva la semantica del programma tradotto, quindi l'insieme delle funzioni che il linguaggio può calcolare

## Domande

## Referenze
