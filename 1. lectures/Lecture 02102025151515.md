---
tags:
  - category/lecture
  - status/finished
  - topic/basi-di-dati
date: 02-10-2025 15:15:15
teacher: danilo.montesi@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- linguaggi dei database
	- sono linguaggi dichiarativi
	- linguaggi per le query
		- _algebra relazionale_ - procedurale
		- _calcolo relazionale_ - dichiarativo, teorico, non implementato
		- _SQL_ - parzialmene dichiarativo
		- _QBE_ - dichiarativo
- **algebra relazionale**
	- operatori
		- lavorano su relazioni
		- producono come risultato delle relazioni
		- e possono essere composti tra loro
		- lista
			- unione, intersezione, differenza
			- rinomina
			- select
			- proietta
			- join --> più importante
				- natural join
				- prodotto cartesiano
				- $\theta$-join
		- i risultati sono relazioni, e quindi insiemi
			- quindi unione, intersezione e differenza devono essere applicate su relazioni che hanno lo stesso schema
		- analisi
			- _union_
				- è un'unione insiemistica --> se ci sono record uguali tra i due operandi, questi verranno uniti nel risultato
			- _intersection_
			- _difference_
				- dalla prima tabella si tolgono gli elementi che sono anche nella seconda
			- _renaming_
				- operatore unario
				- importante per poter fare union
				- rinomina un attributo di uno schema
				- sintassi: $\rho_{NewName \ot OldName}(RELATION)$
			- _select_
				- operatore unario
				- come risultato produce una relazione definita esattamente come lo stesso schema della relazione in input, ma con un _sottoinsieme di tuple che soddisfano un qualche predicato_
				- sintassi: $\sigma_{predicate}(RELATION)$
					- il predicato è un'espressione booleana sulle tuple della relazione
			- _projection_
				- sempre operatore unario
				- lo schema dell'output è un sottoinsieme dello schema dell'input, e l'output è formato da tutte le tuple dell'input (ma solo sul sottoschema)
				- sintassi: $\pi_{AttributeList}(RELATION)$
				- cardinalità della proiezione
					- l'output contiene al più lo stesso numero delle tuple in input
					- non per forza lo stesso numero! Infatti, se si restringe a un sottoinsieme degli attributi, più tuple potrebbero ripetersi, e quindi collassare in una unica
					- teorema easy: se $X$ è una superchiave di $R$, allora $\pi_{X}(R)$ contiene lo stesso numero di tuple di $R$
			- selezione e proiezione sono ortogonali!
				- la selezione filtra orizzontalmente, sulle righe
				- la proiezione filtra verticalmente, sulle colonne
				- combinandole posso estrarre da una relazione solo le informazioni che mi servono
					- $\pi_{Number, Surname}(\sigma_{Salary > 50}(EMPLOYEE))$
					- limiti --> possiamo estrarre informazioni solo da una singola relazione --> non possiamo né fare correlazioni inter-relazionali, né farne intra-relazionali
			- _join_
				- realizza proprio la correlazione tra tuple in diverse relazioni
				- è un'operazione di congiunzione
				- vari tipi
					- _natural join_
						- operatore binario (generalizzabile a più tabelle con associatività)
						- fornisce:
							- congiunzione delle due tabelle sulla base di 2 attributi che hanno lo stesso nome
							- lo schema è l'unione degli attributi dei due schemi
							- ogni tupla è prodotta combinando due tuple, una per ogni relazione
							- sintassi: dati $R_{1}(X_{1}), R_{2}(X_{2})$ $R_{1} \Join R_{2}$ è una relazione su uno schema $X_{1}X_{2}$ (l'unione degli attributi)
								- semantica: ...
						- capiamo che il costo computazionale è terribile: _prodotto tra le cardinalità delle due relazioni_
						- full join
							- quando avviene una completa associazione tra le due relazioni, ossia nessun record è lasciato fuori dalla risposta finale --> ogni tupla contribuisce al risultato finale
							- esempio
						- not-full join
							- alcune tuple non contribuiscono al risultato finale
						- empty join
							- nessuna tupla contribuisce al risultato finale --> la relazione è vuota
						- max join
							- la cardinalità massima in una full join in cui ogni tupla della prima relazione combacia con tutte le tuple della seconda
							- in tal caso la relazione finale è letteralmente il prodotto cartesiano, quindi ha cardinalità $n \times m$
						- cardinalità di una join
							- $$0 \leq |R_{1} \Join R_{2}| \leq |R_{1}| \times |R_{2}|$$
							- se il join coinvolge una chiave di $R_{2}$, allora la cardinalità della join è $0 \leq |R_{1} \Join R_{2}| \leq |R_{1}|$
							- se il join coinvolge una chiave di $R_{2}$, e ha un vincolo di integrità referenziale, il numero delle tuple è $|R_{1} \Join R_{2}| = |R_{1}|$
						- aspetti critici delle non-full join
							- potrebbero causare problemi
							- si usano le _outer join_
								- riempiono con `NULL` i valori delle tuple non prese in considerazione nella "inner" join
								- ce ne sono 3 tipi:
									- _left outer join_
									- _right outer join_
									- _full outer join_
					- _prodotto cartesiano_
						- avviene nel caso in cui le due relazioni hanno intersezione degli schemi vuota, perché nessun campo collassa e viene congiunto
						- nella pratica, il prodotto cartesiano è utile solo se è seguito da un'operazione di selezione
					- _$\theta$-join_
						- è semplicemente l'operatore di selezione di una condizione sul prodotto cartesiano (sulla join nel caso generico)
						- è solamente una select su un prodotto cartesiano
						- la condizione esprime una relazione binaria
							- es. _equi-join_
								- questa collassa in una join con rinominazione!

## Domande

## Referenze
