---
tags:
  - category/lecture
  - status/finished
  - topic/algoritmi-e-strutture-dati
date: 07-03-2024 09:14:39
teacher: pietro.dilena@unibo.it
mod: 1
---
# Lezione
---
## Concetti
- [[Strutture dati elementari]]
	- liste, pile, code
	- caratteristiche di Java: [[Garbage collector|garbage collector]]
	- strutture dati
		- una struttura dati definisce come i _dati sono logicamente organizzati_, e le _operazioni per accedere e modificare i dati_
			- attenzione: non definisce quali tipi di dati sono memorizzati, ma come sono memorizzati
			- per esempio una lista di interi o di stringhe è la stessa struttura dati, ha solo tipi diversi
		- strutture dati elementari
			- liste concatenate --> LinkedList
			- pile --> Stack
			- code --> Queue
		- preliminari:
			- prototipo --> possibili valori ed operazioni di una struttura dati; nasconde i dettagli implementativi; permette al programmatore di implementare la struttura dati e di capire come usarla
			- implementazione --> realizzazione di una struttura dati in qualche linguaggio di programmazione; invisibile all'utente; può avere un forte impatto sui tempi di esecuzione (di un prototipo si possono avere diverse implementazioni)
				- per esempio ArrayList e LinkedList in Java hanno implementazioni diverse, perciò possono avere efficienze differenti a seconda dei problemi
		- strutture dati:
			- **dizionario**, o array associativo
				- contiene un insieme di chiavi univoche, ognuna delle quali è associata a dei dati
				- i dati possono essere duplicati, mentre le chiavi no
				- nota: la usiamo come modo per studiare altre strutture dati, il dizionario sarà il prototipo che andremo a implementare in vari modi, fino a trovare lo standard, il più efficiente
					- valuteremo 6 possibili implementazioni dei dizionari
				- operazioni:
					- `search(Key k)`, cerca e ritorna i dati associati alla chiave `k` nel dizionario, e se `k` non compare ritorna `NIL`
					- `insert(Key k, Data d)`, aggiunge la coppia `(k, d)` al dizionario, e se `k` è già presente nel dizionario sostituisce il dato associato con quello nuovo (sovrascrive)
					- `delete(Key k)`, elimina la coppia `(k, d)` dal dizionario, e se `k` non è nel dizionario non fa nulla
				- implementazioni:
					- _array non ordinato_:
						- l'ordinamento delle chiavi è casuale
						- `search(Key k)`, cerca la chiave `k` tramite _ricerca lineare_ sull'array, ritorna i dati associati a `k` oppure `NIL`
							- caso ottimo: $O(1)$
							- caso pessimo: $\Theta(n)$
							- caso medio: $\Theta(n)$
						- `insert(Key k, Data d)`, verifichiamo con la ricerca lineare se `k` è presente nell'array, e se `k` è presente sostituiamo i dati altrimenti inseriamo la coppia `(k, d)` nella prima cella libera, ovvero quella in fondo all'array
							- caso ottimo: $O(1)$
							- caso pessimo: $\Theta(n)$
							- caso medio: $\Theta(n)$
						- `delete(Key k)`, verifichiamo con la ricerca lineare se `k` è presente nell'array, e se è presente sostituiamo la coppia in fondo all'array con quella da rimuovere (riducendo la dimensione di 1)
							- caso ottimo: $O(1)$
							- caso pessimo: $\Theta(n)$
							- caso medio: $\Theta(n)$
						- in generale possiamo dire, senza considerare la distinzione tra i casi e quindi adottando solo l'[[O-grande]] (consideriamo solo l'upper-bound), che
							- `search`: $O(n)$
							- `insert`: $O(n)$
							- `delete`: $O(n)$
					- _array ordinato_
						- il limite dell'array non ordinato è dovuto alla ricerca lineare, perciò sostituiamolo con la ricerca binaria, a patto di mantenere ordinato l'array sulle chiavi!
						- `search(Key k)`, è una ricerca binaria sulle chiavi
							- per cui il costo delle operazioni dipende dalla ricerca binaria
						- `insert(Key k, Data d)`
							- cerca la chiave con ricerca binaria modificata (in modo che se non esiste returni la posizione in cui dev'essere inserita)
							- se `k` è nell'array sostituiamo i dati, altrimenti dobbiamo shiftare l'array per fare spazio alla nuova chiave
							- il costo delle operazioni dipende dalla ricerca binaria modificata e da `rightshift`
								- caso pessimo: $\Theta(\log{n} + n) = \Theta(n)$
								- caso ottimo: $O(\log{n})$, attenzione perché non è banale
									- `binsearchpos` e `rightshift` sono in contrasto tra di loro (il caso pessimo di uno è l'ottimo dell'altro)
								- caso medio: $\Theta(n)$
						- `delete(Key k)`
							- cerca la chiave con ricerca binaria
							- se `k` è presente fa uno shift di tutto il sotto-array per `k` > 1
							- costi simili all'`insert`
								- caso pessimo: $\Theta(n)$
								- caso ottimo: $O(\log{n})$ (stesso ragionamento di `insert`)
								- caso medio: $\Theta(n)$
						- riassunto sintetico
							- `search`: $O(\log{n})$
							- `insert`: $O(n)$
							- `delete`: $O(n)$
							- abbiamo avuto un miglioramento in `search`
					- _tabelle hash_ come migliore soluzione
		- elementari:
			- **lista**
				- struttura dati in cui gli elementi sono organizzati in ordine sequenziale con almeno tre operazioni basilari: ricerca, inserimento, rimozione
				- implementazioni:
					- _array_
						- ordine sequenziale determinato dagli indici
						- spazio allocato staticamente, e quindi limitato
						- accesso veloce agli elementi ($O(1)$)
					- _liste concatenate_ (Linked Lists)
						- ordinamento determinato da una _catena di puntatori_
						- spazio allocato dinamicamente
						- costo di accesso dipende dalla posizione (per cui lineare)
						- attribuite a Newell, Shaw, Simon, sviluppatori di IPL
						- sono state ideate per contrastare il problema della rilocalizzazione di un array (per il ridimensionamento), che non sempre è possibile
							- un array richiede celle contigue, le liste concatenate no
						- liste concatenate semplici
							- nodi contenenti:
								- dati
								- puntatore al nodo successivo (se è NIL allora è l'ultimo nodo)
							- `search`
								- come una ricerca lineare, stessi costi
								- costo: $\Theta(n)$ (nell'ottimo $O(1)$, pessimo e medio $\Theta(n)$)
							- `insert` (in testa)
								- costo: $O(1)$
							- `append` (in coda)
								- costo: $\Theta(n)$
							- `delete`
								- costo: $\Theta(n)$ (nell'ottimo $O(1)$, pessimo e medio $\Theta(n)$)
						- liste doppiamente concatenate
							- nodi contenenti:
								- dati
								- puntatore al nodo successivo (se è NIL è l'ultimo)
								- puntatore al nodo precedente (se è NIL è il primo)
							- tutte le operazioni hanno lo stesso costo delle liste concatenate semplici
						- liste concatenate circolari
							- note positive: accesso alla testa dalla coda costante, e viceversa!
							- ma non NIL per fine lista
						- liste con puntatori a testa e coda
							- accesso alla testa e alla coda veloce
							- stessi costi delle liste concatenate circolari, ma senza il problema del NIL mancante --> più semplice a livello implementativo
								- infatti guardiamo i vari pseudo-codici delle operazioni su questa implementazione
								- funzionamento del garbage collector: periodicamente va a deallocare tutte le celle in heap che non sono puntate da alcun puntatore
						- riassunto complessivo dei costi per ogni implementazione delle liste concatenate
					- 

## Domande

## Referenze
